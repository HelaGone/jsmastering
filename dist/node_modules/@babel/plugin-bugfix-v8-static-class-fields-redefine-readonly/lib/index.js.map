{"version":3,"file":"index.js","names":["isNameOrLength","key","core","types","isIdentifier","name","isStringLiteral","value","isStaticFieldWithValue","node","isClassProperty","isClassPrivateProperty","hasReferenceVisitor","ReferencedIdentifier","path","state","ref","stop","Scope","_ref","scope","hasOwnBinding","skip","isReferenceOrThis","isThisExpression","hasReferenceOrThisVisitor","ThisExpressionReferencedIdentifier","FunctionParent","isArrowFunctionExpression","traverse","isMethod","helperEnvironmentVisitor","requeueComputedKeyAndDecorators","getPotentiallyBuggyFieldsIndexes","_path$node$id","buggyPublicStaticFieldsIndexes","classReferenced","className","id","hasReferenceState","_iterator","_createForOfIteratorHelper","get","_step","s","n","done","el","computed","err","e","f","nextPotentiallyBuggy","body","i","length","isStaticBlock","concat","isPure","push","getNameOrLengthStaticFieldsIndexes","indexes","toRanges","nums","ranges","start","end","Error","buildFieldsReplacement","fields","file","staticBlock","map","field","stringLiteral","expressionStatement","callExpression","addHelper","thisExpression","buildUndefinedNode","index","helperPluginUtils","declare","api","assertVersion","setPublicClassFields","assumption","visitor","Class","_ranges$i","_slicedToArray","startPath","replaceWith","slice","j","remove"],"sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import type { NodePath, Visitor } from \"@babel/traverse\";\nimport { types as t } from \"@babel/core\";\nimport { requeueComputedKeyAndDecorators } from \"@babel/helper-environment-visitor\";\n\nfunction isNameOrLength(key: t.Node): boolean {\n  if (t.isIdentifier(key)) {\n    return key.name === \"name\" || key.name === \"length\";\n  }\n  if (t.isStringLiteral(key)) {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\n\nfunction isStaticFieldWithValue(\n  node: t.Node,\n): node is t.ClassProperty | t.ClassPrivateProperty {\n  return (\n    (t.isClassProperty(node) || t.isClassPrivateProperty(node)) &&\n    node.static &&\n    !!node.value\n  );\n}\n\nconst hasReferenceVisitor: Visitor<{ name: string; ref: () => void }> = {\n  ReferencedIdentifier(path, state) {\n    if (path.node.name === state.name) {\n      state.ref();\n      path.stop();\n    }\n  },\n  Scope(path, { name }) {\n    if (path.scope.hasOwnBinding(name)) {\n      path.skip();\n    }\n  },\n};\n\nfunction isReferenceOrThis(node: t.Node, name?: string) {\n  return t.isThisExpression(node) || (name && t.isIdentifier(node, { name }));\n}\n\nconst hasReferenceOrThisVisitor: Visitor<{ name?: string; ref: () => void }> = {\n  \"ThisExpression|ReferencedIdentifier\"(path, state) {\n    if (isReferenceOrThis(path.node, state.name)) {\n      state.ref();\n      path.stop();\n    }\n  },\n  FunctionParent(path, state) {\n    if (path.isArrowFunctionExpression()) return;\n    if (state.name && !path.scope.hasOwnBinding(state.name)) {\n      path.traverse(hasReferenceVisitor, state);\n    }\n    path.skip();\n    if (path.isMethod()) {\n      requeueComputedKeyAndDecorators(path);\n    }\n  },\n};\n\ntype ClassElementWithComputedKeySupport = Extract<\n  t.ClassBody[\"body\"][number],\n  { computed?: boolean }\n>;\n\n/**\n * This function returns an array containing the indexes of class elements\n * that might be affected by https://crbug.com/v8/12421 bug.\n *\n * This bug affects public static class fields that have the same name as an\n * existing non-writable property with the same name. This usually happens when\n * the static field is named 'length' or 'name', since it clashes with the\n * predefined fn.length and fn.name properties. We must also compile static\n * fields with computed key, because they might end up being named 'length' or\n * 'name'.\n *\n * However, this bug can potentially affect public static fields with any name.\n * Consider this example:\n *\n *     class A {\n *       static {\n *         Object.defineProperty(A, \"readonly\", {\n *           value: 1,\n *           writable: false,\n *           configurable: true\n *         })\n *       }\n *\n *       static readonly = 2;\n *     }\n *\n * When initializing the 'static readonly' field, the class already has a\n * non-writable property named 'readonly' and thus V8 9.7 incorrectly throws.\n *\n * To avoid unconditionally compiling every public static field, we track how\n * the class is referenced during definition & static evaluation: any side\n * effect after a reference to the class can potentially define a non-writable\n * conficting property, so subsequent public static fields must be compiled.\n * The class could be referenced using the class name in computed keys, which\n * run before static fields, or using either the class name or 'this' in static\n * fields (both public and private) and static blocks.\n *\n * We don't need to check if computed keys referencing the class have any side\n * effect, because during the computed keys evaluation the internal class\n * binding is in TDZ. However, the first side effect in a static field/block\n * could have access to a function defined in a computed key that modifies the\n * class.\n *\n * This logic is already quite complex, so we assume that static blocks always\n * have side effects and reference the class (the reason to use them is to\n * perform additional initialization logic on the class anyway), so that we do\n * not have to check their contents.\n */\nexport function getPotentiallyBuggyFieldsIndexes(path: NodePath<t.Class>) {\n  const buggyPublicStaticFieldsIndexes: number[] = [];\n\n  let classReferenced = false;\n  const className = path.node.id?.name;\n\n  const hasReferenceState = {\n    name: className,\n    ref: () => (classReferenced = true),\n  };\n\n  if (className) {\n    for (const el of path.get(\"body.body\")) {\n      if ((el.node as ClassElementWithComputedKeySupport).computed) {\n        // Since .traverse skips the top-level node, it doesn't detect\n        // a reference happening immediately:\n        //     class A { [A]() {} }\n        // However, it's a TDZ error so it's ok not to consider this case.\n        (el as NodePath<ClassElementWithComputedKeySupport>)\n          .get(\"key\")\n          .traverse(hasReferenceVisitor, hasReferenceState);\n\n        if (classReferenced) break;\n      }\n    }\n  }\n\n  let nextPotentiallyBuggy = false;\n\n  const { body } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n\n    if (!nextPotentiallyBuggy) {\n      if (t.isStaticBlock(node)) {\n        classReferenced = true;\n        nextPotentiallyBuggy = true;\n      } else if (isStaticFieldWithValue(node)) {\n        if (!classReferenced) {\n          if (isReferenceOrThis(node.value, className)) {\n            classReferenced = true;\n          } else {\n            (\n              path.get(`body.body.${i}.value`) as NodePath<t.Expression>\n            ).traverse(hasReferenceOrThisVisitor, hasReferenceState);\n          }\n        }\n\n        if (classReferenced) {\n          nextPotentiallyBuggy = !path.scope.isPure(node.value);\n        }\n      }\n    }\n\n    if (\n      t.isClassProperty(node, { static: true }) &&\n      (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))\n    ) {\n      buggyPublicStaticFieldsIndexes.push(i);\n    }\n  }\n\n  return buggyPublicStaticFieldsIndexes;\n}\n\nexport function getNameOrLengthStaticFieldsIndexes(path: NodePath<t.Class>) {\n  const indexes: number[] = [];\n\n  const { body } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n    if (\n      t.isClassProperty(node, { static: true, computed: false }) &&\n      isNameOrLength(node.key)\n    ) {\n      indexes.push(i);\n    }\n  }\n\n  return indexes;\n}\n\ntype Range = [start: number, end: number];\n\n/**\n * Converts a sorted list of numbers into a list of (inclusive-exclusive)\n * ranges representing the same numbers.\n *\n * @example toRanges([1, 3, 4, 5, 8, 9]) -> [[1, 2], [3, 6], [8, 10]]\n */\nexport function toRanges(nums: number[]): Range[] {\n  const ranges: Range[] = [];\n\n  if (nums.length === 0) return ranges;\n\n  let start = nums[0];\n  let end = start + 1;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] <= nums[i - 1]) {\n      throw new Error(\"Internal Babel error: nums must be in ascending order\");\n    }\n    if (nums[i] === end) {\n      end++;\n    } else {\n      ranges.push([start, end]);\n      start = nums[i];\n      end = start + 1;\n    }\n  }\n  ranges.push([start, end]);\n\n  return ranges;\n}\n","import type { NodePath, Scope } from \"@babel/traverse\";\nimport { types as t, type PluginPass, type File } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nimport {\n  getPotentiallyBuggyFieldsIndexes,\n  getNameOrLengthStaticFieldsIndexes,\n  toRanges,\n} from \"./util.ts\";\n\nfunction buildFieldsReplacement(\n  fields: t.ClassProperty[],\n  scope: Scope,\n  file: File,\n) {\n  return t.staticBlock(\n    fields.map(field => {\n      const key =\n        field.computed || !t.isIdentifier(field.key)\n          ? field.key\n          : t.stringLiteral(field.key.name);\n\n      return t.expressionStatement(\n        t.callExpression(file.addHelper(\"defineProperty\"), [\n          t.thisExpression(),\n          key,\n          field.value || scope.buildUndefinedNode(),\n        ]),\n      );\n    }),\n  );\n}\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n\n  return {\n    name: \"bugfix-v8-static-class-fields-redefine-readonly\",\n\n    visitor: {\n      Class(this: PluginPass, path: NodePath<t.Class>) {\n        const ranges = toRanges(\n          setPublicClassFields\n            ? getNameOrLengthStaticFieldsIndexes(path)\n            : getPotentiallyBuggyFieldsIndexes(path),\n        );\n\n        for (let i = ranges.length - 1; i >= 0; i--) {\n          const [start, end] = ranges[i];\n\n          const startPath = path.get(\"body.body\")[start];\n\n          startPath.replaceWith(\n            buildFieldsReplacement(\n              path.node.body.body.slice(start, end) as t.ClassProperty[],\n              path.scope,\n              this.file,\n            ),\n          );\n\n          for (let j = end - 1; j > start; j--) {\n            path.get(\"body.body\")[j].remove();\n          }\n        }\n      },\n    },\n  };\n});\n"],"mappings":"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","ignoreList":[]}