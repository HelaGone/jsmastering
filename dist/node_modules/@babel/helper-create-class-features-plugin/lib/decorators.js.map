{"version":3,"file":"decorators.js","names":["_core","require","_helperReplaceSupers","_helperSplitExportDeclaration","_helperSkipTransparentExpressionWrappers","_fields","_misc","incrementId","id","idx","arguments","length","undefined","unshift","current","createPrivateUidGeneratorForClass","classPath","currentPrivateId","privateNames","Set","traverse","PrivateName","path","add","node","name","reifiedId","String","fromCharCode","apply","has","types","privateName","identifier","createLazyPrivateUidGeneratorForClass","generator","replaceClassWithVar","className","scope","type","varId","generateUidIdentifierBasedOnNode","classId","rename","get","replaceWith","cloneNode","generateLetUidIdentifier","parent","newClassExpr","classExpression","superClass","body","_path$replaceWith","sequenceExpression","_path$replaceWith2","_slicedToArray","newPath","generateClassProperty","key","value","isStatic","classPrivateProperty","classProperty","addProxyAccessorsFor","element","getterKey","setterKey","targetKey","isComputed","version","thisArg","thisExpression","getterBody","blockStatement","returnStatement","memberExpression","setterBody","expressionStatement","assignmentExpression","getter","setter","classPrivateMethod","classMethod","insertAfter","extractProxyAccessorsFor","template","expression","ast","_templateObject","_taggedTemplateLiteral","_templateObject2","_templateObject3","_templateObject4","getComputedKeyLastElement","skipTransparentExprWrappers","isSequenceExpression","expressions","getComputedKeyMemoiser","isConstantExpression","isIdentifier","hasUid","isAssignmentExpression","left","Error","concat","toString","prependExpressionsToComputedKey","fieldPath","push","_toConsumableArray","maybeSequenceExpression","appendExpressionsToComputedKey","completion","scopeParent","maybeAssignment","memoiseComputedKey","generateUid","expressionSequence","completionParent","parentPath","pushContainer","prependExpressionsToFieldInitializer","initializer","unaryExpression","prependExpressionsToStaticBlock","blockPath","unshiftContainer","prependExpressionsToConstructor","constructorPath","isProtoInitCallExpression","protoInitCall","isCallExpression","callee","optimizeSuperCallAndExpressions","protoInitLocal","mergedSuperCall","callExpression","splice","isThisExpression","insertExpressionsAfterSuperCallAndOptimize","CallExpression","exit","isSuper","newNodes","map","expr","isCompletionRecord","skip","ClassMethod","kind","createConstructorFromExpressions","isDerivedClass","spreadElement","restElement","createStaticBlockFromExpressions","staticBlock","FIELD","ACCESSOR","METHOD","GETTER","SETTER","STATIC_OLD_VERSION","STATIC","DECORATORS_HAVE_THIS","getElementKind","toSortedDecoratorInfo","info","filter","el","generateDecorationList","decorators","decoratorsThis","decsCount","haveOneThis","some","Boolean","decs","i","numericLiteral","haveThis","generateDecorationExprs","decorationInfo","arrayExpression","flag","decoratorsHaveThis","decoratorsArray","privateMethods","extractElementLocalAssignments","localIds","_iterator","_createForOfIteratorHelper","_step","s","n","done","locals","Array","isArray","err","e","f","addCallAccessorsFor","getId","setId","movePrivateAccessor","methodLocalVar","params","block","isClassDecoratableElementPath","staticBlockToIIFE","arrowFunctionExpression","staticBlockToFunctionClosure","functionExpression","fieldInitializerToClosure","exprs","createFunctionExpressionFromPrivateMethod","isGenerator","isAsync","async","createSetFunctionNameCall","state","addHelper","createToPropertyKeyCall","propertyKey","createPrivateBrandCheckClosure","brandName","binaryExpression","usesFunctionContextOrYieldAwait","traverseFast","isYieldExpression","isAwaitExpression","isMetaProperty","meta","_unused","usesPrivateField","isPrivateName","_unused2","convertToComputedKey","computed","stringLiteral","hasInstancePrivateAccess","containsInstancePrivateAccess","privateNameVisitor","privateNameVisitorFactory","privateNamesMap","stop","Map","_iterator2","_step2","set","checkPrivateMethodUpdateError","decoratedPrivateMethods","parentParentPath","buildCodeFrameError","_iterator3","_step3","transformClass","constantSuper","ignoreFunctionLength","propertyVisitor","_classDecorationsId","classDecorators","hasElementDecorators","hasComputedKeysSideEffects","elemDecsUseFnContext","generateClassPrivateUid","classAssignments","memoiseExpression","hint","assignments","localEvaluatedId","staticInitLocal","instancePrivateNames","_iterator4","_step4","elementNode","isDecorated","ClassProperty","ClassPrivateProperty","ClassAccessorProperty","_staticInitLocal","_protoInitLocal","newId","newField","keyPath","_element2$replaceWith","_element2$replaceWith2","elementDecoratorInfo","classInitLocal","classIdLocal","decoratorReceiverId","handleDecoratorExpressions","hasSideEffects","usesFnContext","_iterator5","_step5","object","isMemberExpression","_decoratorReceiverId","willExtractSomeElemDecs","needsDeclaraionForClassBinding","classDecorationsFlag","classDecorations","classDecorationsId","computedKeyAssignments","isClassDeclaration","_replaceClassWithVar","decoratorExpressions","classDecsUsePrivateName","_handleDecoratorExpre","_generateDecorationLi","_iterator6","_step6","isClassProperty","generateUidIdentifier","lastInstancePrivateName","needsInstancePrivateBrandCheck","fieldInitializerExpressions","staticFieldInitializerExpressions","_iterator7","_step7","isStaticBlock","hasDecorators","d","_handleDecoratorExpre2","_generateDecorationLi2","isPrivate","isClassPrivateProperty","isClassMethod","nameExpr","newFieldInitId","newValue","_element$replaceWith","_element$replaceWith2","initId","valuePath","args","callId","replaceSupers","methodPath","objectRef","superRef","file","refToPreserve","replace","remove","getNextSibling","initExtraId","initExtraCall","elements","lastComputedElement","sortedElementDecoratorInfo","elementDecorations","elementLocals","classLocals","classInitInjected","classInitCall","originalClassPath","originalClass","staticClosures","statics","forEach","staticBlockClosureId","fieldValueClosureId","isClassPrivateMethod","privateMethodDelegateId","p","isRestElement","staticsClass","_templateObject5","toExpression","constructorBody","newExpr","newExpression","_path$replaceWith3","_path$replaceWith4","maybeGenerateMemoised","applyDecoratorWrapper","applyDecsBody","firstPublicElement","_iterator8","_step8","createLocalsAssignment","_typeof","insertBefore","variableDeclaration","variableDeclarator","size","crawl","maybePrivateBrandName","setClassName","lhs","rhs","availableHelper","arrayPattern","objectPattern","objectProperty","isProtoKey","shouldTransformElement","shouldTransformClass","NamedEvaluationVisitoryFactory","isAnonymous","visitor","handleComputedProperty","propertyPath","keyValue","ref","VariableDeclarator","AssignmentExpression","operator","AssignmentPattern","ObjectExpression","_iterator9","_step9","isDecoratedAnonymousClassExpression","isClassExpression","_default","_ref","_ref2","inherits","assertVersion","assumption","loose","_assumption","_assumption2","VISITED","WeakSet","namedEvaluationVisitor","visitClass","_className","_node$id","Object","assign","ExportDefaultDeclaration","declaration","updatedVarDeclarationPath","ExportNamedDeclaration","Class"],"sources":["../src/decorators.ts"],"sourcesContent":["import type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport { types as t, template } from \"@babel/core\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport * as charCodes from \"charcodes\";\nimport type { PluginAPI, PluginObject, PluginPass } from \"@babel/core\";\nimport { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport {\n  privateNameVisitorFactory,\n  type PrivateNameVisitorState,\n} from \"./fields.ts\";\nimport { memoiseComputedKey } from \"./misc.ts\";\n\ninterface Options {\n  /** @deprecated use `constantSuper` assumption instead. Only supported in 2021-12 version. */\n  loose?: boolean;\n}\n\ntype ClassDecoratableElement =\n  | t.ClassMethod\n  | t.ClassPrivateMethod\n  | t.ClassProperty\n  | t.ClassPrivateProperty\n  | t.ClassAccessorProperty;\n\ntype ClassElement =\n  | ClassDecoratableElement\n  | t.TSDeclareMethod\n  | t.TSIndexSignature\n  | t.StaticBlock;\n\ntype ClassElementCanHaveComputedKeys =\n  | t.ClassMethod\n  | t.ClassProperty\n  | t.ClassAccessorProperty;\n\n// TODO(Babel 8): Only keep 2023-11\nexport type DecoratorVersionKind =\n  | \"2023-11\"\n  | \"2023-05\"\n  | \"2023-01\"\n  | \"2022-03\"\n  | \"2021-12\";\n\nfunction incrementId(id: number[], idx = id.length - 1): void {\n  // If index is -1, id needs an additional character, unshift A\n  if (idx === -1) {\n    id.unshift(charCodes.uppercaseA);\n    return;\n  }\n\n  const current = id[idx];\n\n  if (current === charCodes.uppercaseZ) {\n    // if current is Z, skip to a\n    id[idx] = charCodes.lowercaseA;\n  } else if (current === charCodes.lowercaseZ) {\n    // if current is z, reset to A and carry the 1\n    id[idx] = charCodes.uppercaseA;\n    incrementId(id, idx - 1);\n  } else {\n    // else, increment by one\n    id[idx] = current + 1;\n  }\n}\n\n/**\n * Generates a new private name that is unique to the given class. This can be\n * used to create extra class fields and methods for the implementation, while\n * keeping the length of those names as small as possible. This is important for\n * minification purposes (though private names can generally be minified,\n * transpilations and polyfills cannot yet).\n */\nfunction createPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  const currentPrivateId: number[] = [];\n  const privateNames = new Set<string>();\n\n  classPath.traverse({\n    PrivateName(path) {\n      privateNames.add(path.node.id.name);\n    },\n  });\n\n  return (): t.PrivateName => {\n    let reifiedId;\n    do {\n      incrementId(currentPrivateId);\n      reifiedId = String.fromCharCode(...currentPrivateId);\n    } while (privateNames.has(reifiedId));\n\n    return t.privateName(t.identifier(reifiedId));\n  };\n}\n\n/**\n * Wraps the above generator function so that it's run lazily the first time\n * it's actually required. Several types of decoration do not require this, so it\n * saves iterating the class elements an additional time and allocating the space\n * for the Sets of element names.\n */\nfunction createLazyPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  let generator: () => t.PrivateName;\n\n  return (): t.PrivateName => {\n    if (!generator) {\n      generator = createPrivateUidGeneratorForClass(classPath);\n    }\n\n    return generator();\n  };\n}\n\n/**\n * Takes a class definition and the desired class name if anonymous and\n * replaces it with an equivalent class declaration (path) which is then\n * assigned to a local variable (id). This allows us to reassign the local variable with the\n * decorated version of the class. The class definition retains its original\n * name so that `toString` is not affected, other references to the class\n * are renamed instead.\n */\nfunction replaceClassWithVar(\n  path: NodePath<t.ClassDeclaration | t.ClassExpression>,\n  className: string | t.Identifier | t.StringLiteral | undefined,\n): {\n  id: t.Identifier;\n  path: NodePath<t.ClassDeclaration | t.ClassExpression>;\n} {\n  const id = path.node.id;\n  const scope = path.scope;\n  if (path.type === \"ClassDeclaration\") {\n    const className = id.name;\n    const varId = scope.generateUidIdentifierBasedOnNode(id);\n    const classId = t.identifier(className);\n\n    scope.rename(className, varId.name);\n\n    path.get(\"id\").replaceWith(classId);\n\n    return { id: t.cloneNode(varId), path };\n  } else {\n    let varId: t.Identifier;\n\n    if (id) {\n      className = id.name;\n      varId = generateLetUidIdentifier(scope.parent, className);\n      scope.rename(className, varId.name);\n    } else {\n      varId = generateLetUidIdentifier(\n        scope.parent,\n        typeof className === \"string\" ? className : \"decorated_class\",\n      );\n    }\n\n    const newClassExpr = t.classExpression(\n      typeof className === \"string\" ? t.identifier(className) : null,\n      path.node.superClass,\n      path.node.body,\n    );\n\n    const [newPath] = path.replaceWith(\n      t.sequenceExpression([newClassExpr, varId]),\n    );\n\n    return {\n      id: t.cloneNode(varId),\n      path: newPath.get(\"expressions.0\") as NodePath<t.ClassExpression>,\n    };\n  }\n}\n\nfunction generateClassProperty(\n  key: t.PrivateName | t.Identifier,\n  value: t.Expression | undefined,\n  isStatic: boolean,\n): t.ClassPrivateProperty | t.ClassProperty {\n  if (key.type === \"PrivateName\") {\n    return t.classPrivateProperty(key, value, undefined, isStatic);\n  } else {\n    return t.classProperty(key, value, undefined, undefined, isStatic);\n  }\n}\n\nfunction addProxyAccessorsFor(\n  className: t.Identifier,\n  element: NodePath<ClassDecoratableElement>,\n  getterKey: t.PrivateName | t.Expression,\n  setterKey: t.PrivateName | t.Expression,\n  targetKey: t.PrivateName,\n  isComputed: boolean,\n  isStatic: boolean,\n  version: DecoratorVersionKind,\n): void {\n  const thisArg =\n    (version === \"2023-11\" ||\n      (!process.env.BABEL_8_BREAKING && version === \"2023-05\")) &&\n    isStatic\n      ? className\n      : t.thisExpression();\n\n  const getterBody = t.blockStatement([\n    t.returnStatement(\n      t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),\n    ),\n  ]);\n\n  const setterBody = t.blockStatement([\n    t.expressionStatement(\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),\n        t.identifier(\"v\"),\n      ),\n    ),\n  ]);\n\n  let getter: t.ClassMethod | t.ClassPrivateMethod,\n    setter: t.ClassMethod | t.ClassPrivateMethod;\n\n  if (getterKey.type === \"PrivateName\") {\n    getter = t.classPrivateMethod(\"get\", getterKey, [], getterBody, isStatic);\n    setter = t.classPrivateMethod(\n      \"set\",\n      setterKey as t.PrivateName,\n      [t.identifier(\"v\")],\n      setterBody,\n      isStatic,\n    );\n  } else {\n    getter = t.classMethod(\n      \"get\",\n      getterKey,\n      [],\n      getterBody,\n      isComputed,\n      isStatic,\n    );\n    setter = t.classMethod(\n      \"set\",\n      setterKey as t.Expression,\n      [t.identifier(\"v\")],\n      setterBody,\n      isComputed,\n      isStatic,\n    );\n  }\n\n  element.insertAfter(setter);\n  element.insertAfter(getter);\n}\n\nfunction extractProxyAccessorsFor(\n  targetKey: t.PrivateName,\n  version: DecoratorVersionKind,\n): (t.FunctionExpression | t.ArrowFunctionExpression)[] {\n  if (version !== \"2023-11\" && version !== \"2023-05\" && version !== \"2023-01\") {\n    return [\n      template.expression.ast`\n        function () {\n          return this.${t.cloneNode(targetKey)};\n        }\n      ` as t.FunctionExpression,\n      template.expression.ast`\n        function (value) {\n          this.${t.cloneNode(targetKey)} = value;\n        }\n      ` as t.FunctionExpression,\n    ];\n  }\n  return [\n    template.expression.ast`\n      o => o.${t.cloneNode(targetKey)}\n    ` as t.ArrowFunctionExpression,\n    template.expression.ast`\n      (o, v) => o.${t.cloneNode(targetKey)} = v\n    ` as t.ArrowFunctionExpression,\n  ];\n}\n\n/**\n * Get the last element for the given computed key path.\n *\n * This function unwraps transparent wrappers and gets the last item when\n * the key is a SequenceExpression.\n *\n * @param {NodePath<t.Expression>} path The key of a computed class element\n * @returns {NodePath<t.Expression>} The simple completion result\n */\nfunction getComputedKeyLastElement(\n  path: NodePath<t.Expression>,\n): NodePath<t.Expression> {\n  path = skipTransparentExprWrappers(path);\n  if (path.isSequenceExpression()) {\n    const expressions = path.get(\"expressions\");\n    return getComputedKeyLastElement(expressions[expressions.length - 1]);\n  }\n  return path;\n}\n\n/**\n * Get a memoiser of the computed key path.\n *\n * This function does not mutate AST. If the computed key is not a constant\n * expression, this function must be called after the key has been memoised.\n *\n * @param {NodePath<t.Expression>} path The key of a computed class element.\n * @returns {t.Expression} A clone of key if key is a constant expression,\n * otherwise a memoiser identifier.\n */\nfunction getComputedKeyMemoiser(path: NodePath<t.Expression>): t.Expression {\n  const element = getComputedKeyLastElement(path);\n  if (element.isConstantExpression()) {\n    return t.cloneNode(path.node);\n  } else if (element.isIdentifier() && path.scope.hasUid(element.node.name)) {\n    return t.cloneNode(path.node);\n  } else if (\n    element.isAssignmentExpression() &&\n    element.get(\"left\").isIdentifier()\n  ) {\n    return t.cloneNode(element.node.left as t.Identifier);\n  } else {\n    throw new Error(\n      `Internal Error: the computed key ${path.toString()} has not yet been memoised.`,\n    );\n  }\n}\n\n/**\n * Prepend expressions to the computed key of the given field path.\n *\n * If the computed key is a sequence expression, this function will unwrap\n * the sequence expression for optimal output size.\n *\n * @param {t.Expression[]} expressions\n * @param {(NodePath<\n *     t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty\n *   >)} fieldPath\n */\nfunction prependExpressionsToComputedKey(\n  expressions: t.Expression[],\n  fieldPath: NodePath<\n    t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty\n  >,\n) {\n  const key = fieldPath.get(\"key\") as NodePath<t.Expression>;\n  if (key.isSequenceExpression()) {\n    expressions.push(...key.node.expressions);\n  } else {\n    expressions.push(key.node);\n  }\n  key.replaceWith(maybeSequenceExpression(expressions));\n}\n\n/**\n * Append expressions to the computed key of the given field path.\n *\n * If the computed key is a constant expression or uid reference, it\n * will prepend expressions before the comptued key. Otherwise it will\n * memoise the computed key to preserve its completion result.\n *\n * @param {t.Expression[]} expressions\n * @param {(NodePath<\n *     t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty\n *   >)} fieldPath\n */\nfunction appendExpressionsToComputedKey(\n  expressions: t.Expression[],\n  fieldPath: NodePath<\n    t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty\n  >,\n) {\n  const key = fieldPath.get(\"key\") as NodePath<t.Expression>;\n  const completion = getComputedKeyLastElement(key);\n  if (completion.isConstantExpression()) {\n    prependExpressionsToComputedKey(expressions, fieldPath);\n  } else {\n    const scopeParent = key.scope.parent;\n    const maybeAssignment = memoiseComputedKey(\n      completion.node,\n      scopeParent,\n      scopeParent.generateUid(\"computedKey\"),\n    );\n    if (!maybeAssignment) {\n      // If the memoiseComputedKey returns undefined, the key is already a uid reference,\n      // treat it as a constant expression and prepend expressions before it\n      prependExpressionsToComputedKey(expressions, fieldPath);\n    } else {\n      const expressionSequence = [\n        ...expressions,\n        // preserve the completion result\n        t.cloneNode(maybeAssignment.left),\n      ];\n      const completionParent = completion.parentPath;\n      if (completionParent.isSequenceExpression()) {\n        completionParent.pushContainer(\"expressions\", expressionSequence);\n      } else {\n        completion.replaceWith(\n          maybeSequenceExpression([\n            t.cloneNode(maybeAssignment),\n            ...expressionSequence,\n          ]),\n        );\n      }\n    }\n  }\n}\n\n/**\n * Prepend expressions to the field initializer. If the initializer is not defined,\n * this function will wrap the last expression within a `void` unary expression.\n *\n * @param {t.Expression[]} expressions\n * @param {(NodePath<\n *     t.ClassProperty | t.ClassPrivateProperty | t.ClassAccessorProperty\n *   >)} fieldPath\n */\nfunction prependExpressionsToFieldInitializer(\n  expressions: t.Expression[],\n  fieldPath: NodePath<\n    t.ClassProperty | t.ClassPrivateProperty | t.ClassAccessorProperty\n  >,\n) {\n  const initializer = fieldPath.get(\"value\");\n  if (initializer.node) {\n    expressions.push(initializer.node);\n  } else if (expressions.length > 0) {\n    expressions[expressions.length - 1] = t.unaryExpression(\n      \"void\",\n      expressions[expressions.length - 1],\n    );\n  }\n  initializer.replaceWith(maybeSequenceExpression(expressions));\n}\n\nfunction prependExpressionsToStaticBlock(\n  expressions: t.Expression[],\n  blockPath: NodePath<t.StaticBlock>,\n) {\n  blockPath.unshiftContainer(\n    \"body\",\n    t.expressionStatement(maybeSequenceExpression(expressions)),\n  );\n}\n\nfunction prependExpressionsToConstructor(\n  expressions: t.Expression[],\n  constructorPath: NodePath<t.ClassMethod>,\n) {\n  constructorPath.node.body.body.unshift(\n    t.expressionStatement(maybeSequenceExpression(expressions)),\n  );\n}\n\nfunction isProtoInitCallExpression(\n  expression: t.Expression,\n  protoInitCall: t.Identifier,\n) {\n  return (\n    t.isCallExpression(expression) &&\n    t.isIdentifier(expression.callee, { name: protoInitCall.name })\n  );\n}\n\n/**\n * Optimize super call and its following expressions\n *\n * @param {t.Expression[]} expressions Mutated by this function. The first element must by a super call\n * @param {t.Identifier} protoInitLocal The generated protoInit id\n * @returns optimized expression\n */\nfunction optimizeSuperCallAndExpressions(\n  expressions: t.Expression[],\n  protoInitLocal: t.Identifier,\n) {\n  // Merge `super(), protoInit(this)` into `protoInit(super())`\n  if (\n    expressions.length >= 2 &&\n    isProtoInitCallExpression(expressions[1], protoInitLocal)\n  ) {\n    const mergedSuperCall = t.callExpression(t.cloneNode(protoInitLocal), [\n      expressions[0],\n    ]);\n    expressions.splice(0, 2, mergedSuperCall);\n  }\n  // Merge `protoInit(super()), this` into `protoInit(super())`\n  if (\n    expressions.length >= 2 &&\n    t.isThisExpression(expressions[expressions.length - 1]) &&\n    isProtoInitCallExpression(\n      expressions[expressions.length - 2],\n      protoInitLocal,\n    )\n  ) {\n    expressions.splice(expressions.length - 1, 1);\n  }\n  return maybeSequenceExpression(expressions);\n}\n\n/**\n * Insert expressions immediately after super() and optimize the output if possible.\n * This function will preserve the completion result using the trailing this expression.\n *\n * @param {t.Expression[]} expressions\n * @param {NodePath<t.ClassMethod>} constructorPath\n * @param {t.Identifier} protoInitLocal The generated protoInit id\n * @returns\n */\nfunction insertExpressionsAfterSuperCallAndOptimize(\n  expressions: t.Expression[],\n  constructorPath: NodePath<t.ClassMethod>,\n  protoInitLocal: t.Identifier,\n) {\n  constructorPath.traverse({\n    CallExpression: {\n      exit(path) {\n        if (!path.get(\"callee\").isSuper()) return;\n        const newNodes = [\n          path.node,\n          ...expressions.map(expr => t.cloneNode(expr)),\n        ];\n        // preserve completion result if super() is in an RHS or a return statement\n        if (path.isCompletionRecord()) {\n          newNodes.push(t.thisExpression());\n        }\n        path.replaceWith(\n          optimizeSuperCallAndExpressions(newNodes, protoInitLocal),\n        );\n\n        path.skip();\n      },\n    },\n    ClassMethod(path) {\n      if (path.node.kind === \"constructor\") {\n        path.skip();\n      }\n    },\n  });\n}\n\n/**\n * Build a class constructor node from the given expressions. If the class is\n * derived, the constructor will call super() first to ensure that `this`\n * in the expressions work as expected.\n *\n * @param {t.Expression[]} expressions\n * @param {boolean} isDerivedClass\n * @returns The class constructor node\n */\nfunction createConstructorFromExpressions(\n  expressions: t.Expression[],\n  isDerivedClass: boolean,\n) {\n  const body: t.Statement[] = [\n    t.expressionStatement(maybeSequenceExpression(expressions)),\n  ];\n  if (isDerivedClass) {\n    body.unshift(\n      t.expressionStatement(\n        t.callExpression(t.super(), [t.spreadElement(t.identifier(\"args\"))]),\n      ),\n    );\n  }\n  return t.classMethod(\n    \"constructor\",\n    t.identifier(\"constructor\"),\n    isDerivedClass ? [t.restElement(t.identifier(\"args\"))] : [],\n    t.blockStatement(body),\n  );\n}\n\nfunction createStaticBlockFromExpressions(expressions: t.Expression[]) {\n  return t.staticBlock([\n    t.expressionStatement(maybeSequenceExpression(expressions)),\n  ]);\n}\n\n// 3 bits reserved to this (0-7)\nconst FIELD = 0;\nconst ACCESSOR = 1;\nconst METHOD = 2;\nconst GETTER = 3;\nconst SETTER = 4;\n\nconst STATIC_OLD_VERSION = 5; // Before 2023-05\nconst STATIC = 8; // 1 << 3\nconst DECORATORS_HAVE_THIS = 16; // 1 << 4\n\nfunction getElementKind(element: NodePath<ClassDecoratableElement>): number {\n  switch (element.node.type) {\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n      return FIELD;\n    case \"ClassAccessorProperty\":\n      return ACCESSOR;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (element.node.kind === \"get\") {\n        return GETTER;\n      } else if (element.node.kind === \"set\") {\n        return SETTER;\n      } else {\n        return METHOD;\n      }\n  }\n}\n\n// Information about the decorators applied to an element\ninterface DecoratorInfo {\n  // An array of applied decorators or a memoised identifier\n  decoratorsArray: t.Identifier | t.ArrayExpression | t.Expression;\n  decoratorsHaveThis: boolean;\n\n  // The kind of the decorated value, matches the kind value passed to applyDecs\n  kind: number;\n\n  // whether or not the field is static\n  isStatic: boolean;\n\n  // The name of the decorator\n  name: t.StringLiteral | t.Expression;\n\n  privateMethods:\n    | (t.FunctionExpression | t.ArrowFunctionExpression)[]\n    | undefined;\n\n  // The names of local variables that will be used/returned from the decoration\n  locals: t.Identifier | t.Identifier[] | undefined;\n}\n\n/**\n * Sort decoration info in the application order:\n * - static non-fields\n * - instance non-fields\n * - static fields\n * - instance fields\n *\n * @param {DecoratorInfo[]} info\n * @returns {DecoratorInfo[]} Sorted decoration info\n */\nfunction toSortedDecoratorInfo(info: DecoratorInfo[]): DecoratorInfo[] {\n  return [\n    ...info.filter(\n      el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...info.filter(\n      el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...info.filter(el => el.isStatic && el.kind === FIELD),\n    ...info.filter(el => !el.isStatic && el.kind === FIELD),\n  ];\n}\n\ntype GenerateDecorationListResult = {\n  // The zipped decorators array that will be passed to generateDecorationExprs\n  decs: t.Expression[];\n  // Whether there are non-empty decorator this values\n  haveThis: boolean;\n};\n/**\n * Zip decorators and decorator this values into an array\n *\n * @param {t.Expression[]} decorators\n * @param {((t.Expression | undefined)[])} decoratorsThis decorator this values\n * @param {DecoratorVersionKind} version\n * @returns {GenerateDecorationListResult}\n */\nfunction generateDecorationList(\n  decorators: t.Expression[],\n  decoratorsThis: (t.Expression | undefined)[],\n  version: DecoratorVersionKind,\n): GenerateDecorationListResult {\n  const decsCount = decorators.length;\n  const haveOneThis = decoratorsThis.some(Boolean);\n  const decs: t.Expression[] = [];\n  for (let i = 0; i < decsCount; i++) {\n    if (\n      (version === \"2023-11\" ||\n        (!process.env.BABEL_8_BREAKING && version === \"2023-05\")) &&\n      haveOneThis\n    ) {\n      decs.push(\n        decoratorsThis[i] || t.unaryExpression(\"void\", t.numericLiteral(0)),\n      );\n    }\n    decs.push(decorators[i]);\n  }\n\n  return { haveThis: haveOneThis, decs };\n}\n\nfunction generateDecorationExprs(\n  decorationInfo: DecoratorInfo[],\n  version: DecoratorVersionKind,\n): t.ArrayExpression {\n  return t.arrayExpression(\n    decorationInfo.map(el => {\n      let flag = el.kind;\n      if (el.isStatic) {\n        flag +=\n          version === \"2023-11\" ||\n          (!process.env.BABEL_8_BREAKING && version === \"2023-05\")\n            ? STATIC\n            : STATIC_OLD_VERSION;\n      }\n      if (el.decoratorsHaveThis) flag += DECORATORS_HAVE_THIS;\n\n      return t.arrayExpression([\n        el.decoratorsArray,\n        t.numericLiteral(flag),\n        el.name,\n        ...(el.privateMethods || []),\n      ]);\n    }),\n  );\n}\n\nfunction extractElementLocalAssignments(decorationInfo: DecoratorInfo[]) {\n  const localIds: t.Identifier[] = [];\n\n  for (const el of decorationInfo) {\n    const { locals } = el;\n\n    if (Array.isArray(locals)) {\n      localIds.push(...locals);\n    } else if (locals !== undefined) {\n      localIds.push(locals);\n    }\n  }\n\n  return localIds;\n}\n\nfunction addCallAccessorsFor(\n  version: DecoratorVersionKind,\n  element: NodePath,\n  key: t.PrivateName,\n  getId: t.Identifier,\n  setId: t.Identifier,\n  isStatic: boolean,\n) {\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"get\",\n      t.cloneNode(key),\n      [],\n      t.blockStatement([\n        t.returnStatement(\n          t.callExpression(\n            t.cloneNode(getId),\n            (process.env.BABEL_8_BREAKING || version === \"2023-11\") && isStatic\n              ? []\n              : [t.thisExpression()],\n          ),\n        ),\n      ]),\n      isStatic,\n    ),\n  );\n\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"set\",\n      t.cloneNode(key),\n      [t.identifier(\"v\")],\n      t.blockStatement([\n        t.expressionStatement(\n          t.callExpression(\n            t.cloneNode(setId),\n            (process.env.BABEL_8_BREAKING || version === \"2023-11\") && isStatic\n              ? [t.identifier(\"v\")]\n              : [t.thisExpression(), t.identifier(\"v\")],\n          ),\n        ),\n      ]),\n      isStatic,\n    ),\n  );\n}\n\nfunction movePrivateAccessor(\n  element: NodePath<t.ClassPrivateMethod>,\n  key: t.PrivateName,\n  methodLocalVar: t.Identifier,\n  isStatic: boolean,\n) {\n  let params: (t.Identifier | t.RestElement)[];\n  let block: t.Statement[];\n\n  if (element.node.kind === \"set\") {\n    params = [t.identifier(\"v\")];\n    block = [\n      t.expressionStatement(\n        t.callExpression(methodLocalVar, [\n          t.thisExpression(),\n          t.identifier(\"v\"),\n        ]),\n      ),\n    ];\n  } else {\n    params = [];\n    block = [\n      t.returnStatement(t.callExpression(methodLocalVar, [t.thisExpression()])),\n    ];\n  }\n\n  element.replaceWith(\n    t.classPrivateMethod(\n      element.node.kind,\n      t.cloneNode(key),\n      params,\n      t.blockStatement(block),\n      isStatic,\n    ),\n  );\n}\n\nfunction isClassDecoratableElementPath(\n  path: NodePath<ClassElement>,\n): path is NodePath<ClassDecoratableElement> {\n  const { type } = path;\n\n  return (\n    type !== \"TSDeclareMethod\" &&\n    type !== \"TSIndexSignature\" &&\n    type !== \"StaticBlock\"\n  );\n}\n\nfunction staticBlockToIIFE(block: t.StaticBlock) {\n  return t.callExpression(\n    t.arrowFunctionExpression([], t.blockStatement(block.body)),\n    [],\n  );\n}\n\nfunction staticBlockToFunctionClosure(block: t.StaticBlock) {\n  return t.functionExpression(null, [], t.blockStatement(block.body));\n}\n\nfunction fieldInitializerToClosure(value: t.Expression) {\n  return t.functionExpression(\n    null,\n    [],\n    t.blockStatement([t.returnStatement(value)]),\n  );\n}\n\nfunction maybeSequenceExpression(exprs: t.Expression[]) {\n  if (exprs.length === 0) return t.unaryExpression(\"void\", t.numericLiteral(0));\n  if (exprs.length === 1) return exprs[0];\n  return t.sequenceExpression(exprs);\n}\n\n/**\n * Create FunctionExpression from a ClassPrivateMethod.\n * The returned FunctionExpression node takes ownership of the private method's body and params.\n *\n * @param {t.ClassPrivateMethod} node\n * @returns\n */\nfunction createFunctionExpressionFromPrivateMethod(node: t.ClassPrivateMethod) {\n  const { params, body, generator: isGenerator, async: isAsync } = node;\n  return t.functionExpression(\n    undefined,\n    // @ts-expect-error todo: Improve typings: TSParameterProperty is only allowed in constructor\n    params,\n    body,\n    isGenerator,\n    isAsync,\n  );\n}\n\nfunction createSetFunctionNameCall(\n  state: PluginPass,\n  className: t.Identifier | t.StringLiteral,\n) {\n  return t.callExpression(state.addHelper(\"setFunctionName\"), [\n    t.thisExpression(),\n    className,\n  ]);\n}\n\nfunction createToPropertyKeyCall(state: PluginPass, propertyKey: t.Expression) {\n  return t.callExpression(state.addHelper(\"toPropertyKey\"), [propertyKey]);\n}\n\nfunction createPrivateBrandCheckClosure(brandName: t.PrivateName) {\n  return t.arrowFunctionExpression(\n    [t.identifier(\"_\")],\n    t.binaryExpression(\"in\", t.cloneNode(brandName), t.identifier(\"_\")),\n  );\n}\n\n// Check if the expression does not reference function-specific\n// context or the given identifier name.\n// `true` means \"maybe\" and `false` means \"no\".\nfunction usesFunctionContextOrYieldAwait(expression: t.Node) {\n  try {\n    t.traverseFast(expression, node => {\n      if (\n        t.isThisExpression(node) ||\n        t.isSuper(node) ||\n        t.isYieldExpression(node) ||\n        t.isAwaitExpression(node) ||\n        t.isIdentifier(node, { name: \"arguments\" }) ||\n        (t.isMetaProperty(node) && node.meta.name !== \"import\")\n      ) {\n        // TODO: Add early return support to t.traverseFast\n        throw null;\n      }\n    });\n    return false;\n  } catch {\n    return true;\n  }\n}\n\nfunction usesPrivateField(expression: t.Node) {\n  try {\n    t.traverseFast(expression, node => {\n      if (t.isPrivateName(node)) {\n        // TODO: Add early return support to t.traverseFast\n        throw null;\n      }\n    });\n    return false;\n  } catch {\n    return true;\n  }\n}\n\n/**\n * Convert a non-computed class element to its equivalent computed form.\n *\n * This function is to provide a decorator evaluation storage from non-computed\n * class elements.\n *\n * @param {(NodePath<t.ClassProperty | t.ClassMethod>)} path A non-computed class property or method\n */\nfunction convertToComputedKey(path: NodePath<t.ClassProperty | t.ClassMethod>) {\n  const { node } = path;\n  node.computed = true;\n  if (t.isIdentifier(node.key)) {\n    node.key = t.stringLiteral(node.key.name);\n  }\n}\n\nfunction hasInstancePrivateAccess(path: NodePath, privateNames: string[]) {\n  let containsInstancePrivateAccess = false;\n  if (privateNames.length > 0) {\n    const privateNameVisitor = privateNameVisitorFactory<\n      PrivateNameVisitorState<null>,\n      null\n    >({\n      PrivateName(path, state) {\n        if (state.privateNamesMap.has(path.node.id.name)) {\n          containsInstancePrivateAccess = true;\n          path.stop();\n        }\n      },\n    });\n    const privateNamesMap = new Map<string, null>();\n    for (const name of privateNames) {\n      privateNamesMap.set(name, null);\n    }\n    path.traverse(privateNameVisitor, {\n      privateNamesMap: privateNamesMap,\n    });\n  }\n  return containsInstancePrivateAccess;\n}\n\nfunction checkPrivateMethodUpdateError(\n  path: NodePath<t.Class>,\n  decoratedPrivateMethods: Set<string>,\n) {\n  const privateNameVisitor = privateNameVisitorFactory<\n    PrivateNameVisitorState<null>,\n    null\n  >({\n    PrivateName(path, state) {\n      if (!state.privateNamesMap.has(path.node.id.name)) return;\n\n      const parentPath = path.parentPath;\n      const parentParentPath = parentPath.parentPath;\n\n      if (\n        // this.bar().#x = 123;\n        (parentParentPath.node.type === \"AssignmentExpression\" &&\n          parentParentPath.node.left === parentPath.node) ||\n        // this.#x++;\n        parentParentPath.node.type === \"UpdateExpression\" ||\n        // ([...this.#x] = foo);\n        parentParentPath.node.type === \"RestElement\" ||\n        // ([this.#x] = foo);\n        parentParentPath.node.type === \"ArrayPattern\" ||\n        // ({ a: this.#x } = bar);\n        (parentParentPath.node.type === \"ObjectProperty\" &&\n          parentParentPath.node.value === parentPath.node &&\n          parentParentPath.parentPath.type === \"ObjectPattern\") ||\n        // for (this.#x of []);\n        (parentParentPath.node.type === \"ForOfStatement\" &&\n          parentParentPath.node.left === parentPath.node)\n      ) {\n        throw path.buildCodeFrameError(\n          `Decorated private methods are read-only, but \"#${path.node.id.name}\" is updated via this expression.`,\n        );\n      }\n    },\n  });\n  const privateNamesMap = new Map<string, null>();\n  for (const name of decoratedPrivateMethods) {\n    privateNamesMap.set(name, null);\n  }\n  path.traverse(privateNameVisitor, {\n    privateNamesMap: privateNamesMap,\n  });\n}\n\nfunction transformClass(\n  path: NodePath<t.Class>,\n  state: PluginPass,\n  constantSuper: boolean,\n  ignoreFunctionLength: boolean,\n  className: string | t.Identifier | t.StringLiteral | undefined,\n  propertyVisitor: Visitor<PluginPass>,\n  version: DecoratorVersionKind,\n): NodePath {\n  const body = path.get(\"body.body\");\n\n  const classDecorators = path.node.decorators;\n  let hasElementDecorators = false;\n  let hasComputedKeysSideEffects = false;\n  let elemDecsUseFnContext = false;\n\n  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);\n\n  const classAssignments: t.AssignmentExpression[] = [];\n  const scopeParent: Scope = path.scope.parent;\n  const memoiseExpression = (\n    expression: t.Expression,\n    hint: string,\n    assignments: t.AssignmentExpression[],\n  ) => {\n    const localEvaluatedId = generateLetUidIdentifier(scopeParent, hint);\n    assignments.push(t.assignmentExpression(\"=\", localEvaluatedId, expression));\n    return t.cloneNode(localEvaluatedId);\n  };\n\n  let protoInitLocal: t.Identifier;\n  let staticInitLocal: t.Identifier;\n  const instancePrivateNames: string[] = [];\n  // Iterate over the class to see if we need to decorate it, and also to\n  // transform simple auto accessors which are not decorated, and handle inferred\n  // class name when the initializer of the class field is a class expression\n  for (const element of body) {\n    if (!isClassDecoratableElementPath(element)) {\n      continue;\n    }\n\n    const elementNode = element.node;\n\n    if (!elementNode.static && t.isPrivateName(elementNode.key)) {\n      instancePrivateNames.push(elementNode.key.id.name);\n    }\n\n    if (isDecorated(elementNode)) {\n      switch (elementNode.type) {\n        case \"ClassProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassProperty should be callable. Improve typings.\n          propertyVisitor.ClassProperty(\n            element as NodePath<t.ClassProperty>,\n            state,\n          );\n          break;\n        case \"ClassPrivateProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassPrivateProperty should be callable. Improve typings.\n          propertyVisitor.ClassPrivateProperty(\n            element as NodePath<t.ClassPrivateProperty>,\n            state,\n          );\n          break;\n        case \"ClassAccessorProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassAccessorProperty should be callable. Improve typings.\n          propertyVisitor.ClassAccessorProperty(\n            element as NodePath<t.ClassAccessorProperty>,\n            state,\n          );\n          if (version === \"2023-11\") {\n            break;\n          }\n        /* fallthrough */\n        default:\n          if (elementNode.static) {\n            staticInitLocal ??= generateLetUidIdentifier(\n              scopeParent,\n              \"initStatic\",\n            );\n          } else {\n            protoInitLocal ??= generateLetUidIdentifier(\n              scopeParent,\n              \"initProto\",\n            );\n          }\n          break;\n      }\n      hasElementDecorators = true;\n      elemDecsUseFnContext ||= elementNode.decorators.some(\n        usesFunctionContextOrYieldAwait,\n      );\n    } else if (elementNode.type === \"ClassAccessorProperty\") {\n      // @ts-expect-error todo: propertyVisitor.ClassAccessorProperty should be callable. Improve typings.\n      propertyVisitor.ClassAccessorProperty(\n        element as NodePath<t.ClassAccessorProperty>,\n        state,\n      );\n      const { key, value, static: isStatic, computed } = elementNode;\n\n      const newId = generateClassPrivateUid();\n      const newField = generateClassProperty(newId, value, isStatic);\n      const keyPath = element.get(\"key\");\n      const [newPath] = element.replaceWith(newField);\n\n      let getterKey, setterKey;\n      if (computed && !keyPath.isConstantExpression()) {\n        getterKey = memoiseComputedKey(\n          createToPropertyKeyCall(state, key as t.Expression),\n          scopeParent,\n          scopeParent.generateUid(\"computedKey\"),\n        )!;\n        setterKey = t.cloneNode(getterKey.left as t.Identifier);\n      } else {\n        getterKey = t.cloneNode(key);\n        setterKey = t.cloneNode(key);\n      }\n\n      addProxyAccessorsFor(\n        path.node.id,\n        newPath,\n        getterKey,\n        setterKey,\n        newId,\n        computed,\n        isStatic,\n        version,\n      );\n    }\n\n    if (\"computed\" in element.node && element.node.computed) {\n      hasComputedKeysSideEffects ||= !scopeParent.isStatic(element.node.key);\n    }\n  }\n\n  if (!classDecorators && !hasElementDecorators) {\n    // If nothing is decorated and no assignments inserted, return\n    return;\n  }\n\n  const elementDecoratorInfo: DecoratorInfo[] = [];\n\n  let constructorPath: NodePath<t.ClassMethod> | undefined;\n  const decoratedPrivateMethods = new Set<string>();\n\n  let classInitLocal: t.Identifier, classIdLocal: t.Identifier;\n  let decoratorReceiverId: t.Identifier | null = null;\n\n  // Memoise the this value `a.b` of decorator member expressions `@a.b.dec`,\n  type HandleDecoratorExpressionsResult = {\n    // whether the whole decorator list requires memoisation\n    hasSideEffects: boolean;\n    usesFnContext: boolean;\n    // the this value of each decorator if applicable\n    decoratorsThis: (t.Expression | undefined)[];\n  };\n  function handleDecoratorExpressions(\n    expressions: t.Expression[],\n  ): HandleDecoratorExpressionsResult {\n    let hasSideEffects = false;\n    let usesFnContext = false;\n    const decoratorsThis: (t.Expression | null)[] = [];\n    for (const expression of expressions) {\n      let object;\n      if (\n        (version === \"2023-11\" ||\n          (!process.env.BABEL_8_BREAKING && version === \"2023-05\")) &&\n        t.isMemberExpression(expression)\n      ) {\n        if (t.isSuper(expression.object)) {\n          object = t.thisExpression();\n        } else if (scopeParent.isStatic(expression.object)) {\n          object = t.cloneNode(expression.object);\n        } else {\n          decoratorReceiverId ??= generateLetUidIdentifier(scopeParent, \"obj\");\n          object = t.assignmentExpression(\n            \"=\",\n            t.cloneNode(decoratorReceiverId),\n            expression.object,\n          );\n          expression.object = t.cloneNode(decoratorReceiverId);\n        }\n      }\n      decoratorsThis.push(object);\n      hasSideEffects ||= !scopeParent.isStatic(expression);\n      usesFnContext ||= usesFunctionContextOrYieldAwait(expression);\n    }\n    return { hasSideEffects, usesFnContext, decoratorsThis };\n  }\n\n  const willExtractSomeElemDecs =\n    hasComputedKeysSideEffects ||\n    (process.env.BABEL_8_BREAKING\n      ? elemDecsUseFnContext\n      : elemDecsUseFnContext || version !== \"2023-11\");\n\n  let needsDeclaraionForClassBinding = false;\n  let classDecorationsFlag = 0;\n  let classDecorations: t.Expression[] = [];\n  let classDecorationsId: t.Identifier;\n  let computedKeyAssignments: t.AssignmentExpression[] = [];\n  if (classDecorators) {\n    classInitLocal = generateLetUidIdentifier(scopeParent, \"initClass\");\n    needsDeclaraionForClassBinding = path.isClassDeclaration();\n    ({ id: classIdLocal, path } = replaceClassWithVar(path, className));\n\n    path.node.decorators = null;\n\n    const decoratorExpressions = classDecorators.map(el => el.expression);\n    const classDecsUsePrivateName = decoratorExpressions.some(usesPrivateField);\n    const { hasSideEffects, decoratorsThis } =\n      handleDecoratorExpressions(decoratorExpressions);\n\n    const { haveThis, decs } = generateDecorationList(\n      decoratorExpressions,\n      decoratorsThis,\n      version,\n    );\n    classDecorationsFlag = haveThis ? 1 : 0;\n    classDecorations = decs;\n\n    if (\n      (hasSideEffects && willExtractSomeElemDecs) ||\n      classDecsUsePrivateName\n    ) {\n      classDecorationsId = memoiseExpression(\n        t.arrayExpression(classDecorations),\n        \"classDecs\",\n        classAssignments,\n      );\n    }\n\n    if (!hasElementDecorators) {\n      // Sync body paths as non-decorated computed accessors have been transpiled\n      // to getter-setter pairs.\n      for (const element of path.get(\"body.body\")) {\n        const { node } = element;\n        const isComputed = \"computed\" in node && node.computed;\n        if (isComputed) {\n          if (element.isClassProperty({ static: true })) {\n            if (!element.get(\"key\").isConstantExpression()) {\n              const key = (node as t.ClassProperty).key;\n              const maybeAssignment = memoiseComputedKey(\n                key,\n                scopeParent,\n                scopeParent.generateUid(\"computedKey\"),\n              );\n              if (maybeAssignment != null) {\n                // If it is a static computed field within a decorated class, we move the computed key\n                // into `computedKeyAssignments` which will be then moved into the non-static class,\n                // to ensure that the evaluation order and private environment are correct\n                node.key = t.cloneNode(maybeAssignment.left);\n                computedKeyAssignments.push(maybeAssignment);\n              }\n            }\n          } else if (computedKeyAssignments.length > 0) {\n            prependExpressionsToComputedKey(\n              computedKeyAssignments,\n              element as NodePath<ClassElementCanHaveComputedKeys>,\n            );\n            computedKeyAssignments = [];\n          }\n        }\n      }\n    }\n  } else {\n    if (!path.node.id) {\n      path.node.id = path.scope.generateUidIdentifier(\"Class\");\n    }\n    classIdLocal = t.cloneNode(path.node.id);\n  }\n\n  let lastInstancePrivateName: t.PrivateName;\n  let needsInstancePrivateBrandCheck = false;\n\n  let fieldInitializerExpressions = [];\n  let staticFieldInitializerExpressions: t.Expression[] = [];\n\n  if (hasElementDecorators) {\n    if (protoInitLocal) {\n      const protoInitCall = t.callExpression(t.cloneNode(protoInitLocal), [\n        t.thisExpression(),\n      ]);\n      fieldInitializerExpressions.push(protoInitCall);\n    }\n    for (const element of body) {\n      if (!isClassDecoratableElementPath(element)) {\n        if (\n          staticFieldInitializerExpressions.length > 0 &&\n          element.isStaticBlock()\n        ) {\n          prependExpressionsToStaticBlock(\n            staticFieldInitializerExpressions,\n            element,\n          );\n          staticFieldInitializerExpressions = [];\n        }\n        continue;\n      }\n\n      const { node } = element;\n      const decorators = node.decorators;\n\n      const hasDecorators = !!decorators?.length;\n\n      const isComputed = \"computed\" in node && node.computed;\n\n      let name = \"computedKey\";\n\n      if (node.key.type === \"PrivateName\") {\n        name = node.key.id.name;\n      } else if (!isComputed && node.key.type === \"Identifier\") {\n        name = node.key.name;\n      }\n      let decoratorsArray: t.Identifier | t.ArrayExpression | t.Expression;\n      let decoratorsHaveThis;\n\n      if (hasDecorators) {\n        const decoratorExpressions = decorators.map(d => d.expression);\n        const { hasSideEffects, usesFnContext, decoratorsThis } =\n          handleDecoratorExpressions(decoratorExpressions);\n        const { decs, haveThis } = generateDecorationList(\n          decoratorExpressions,\n          decoratorsThis,\n          version,\n        );\n        decoratorsHaveThis = haveThis;\n        decoratorsArray = decs.length === 1 ? decs[0] : t.arrayExpression(decs);\n        if (usesFnContext || (hasSideEffects && willExtractSomeElemDecs)) {\n          decoratorsArray = memoiseExpression(\n            decoratorsArray,\n            name + \"Decs\",\n            computedKeyAssignments,\n          );\n        }\n      }\n\n      if (isComputed) {\n        if (!element.get(\"key\").isConstantExpression()) {\n          const key = node.key as t.Expression;\n          const maybeAssignment = memoiseComputedKey(\n            hasDecorators ? createToPropertyKeyCall(state, key) : key,\n            scopeParent,\n            scopeParent.generateUid(\"computedKey\"),\n          );\n          if (maybeAssignment != null) {\n            // If it is a static computed field within a decorated class, we move the computed key\n            // into `computedKeyAssignments` which will be then moved into the non-static class,\n            // to ensure that the evaluation order and private environment are correct\n            if (classDecorators && element.isClassProperty({ static: true })) {\n              node.key = t.cloneNode(maybeAssignment.left);\n              computedKeyAssignments.push(maybeAssignment);\n            } else {\n              node.key = maybeAssignment;\n            }\n          }\n        }\n      }\n\n      const { key, static: isStatic } = node;\n\n      const isPrivate = key.type === \"PrivateName\";\n\n      const kind = getElementKind(element);\n\n      if (isPrivate && !isStatic) {\n        if (hasDecorators) {\n          needsInstancePrivateBrandCheck = true;\n        }\n        if (t.isClassPrivateProperty(node) || !lastInstancePrivateName) {\n          lastInstancePrivateName = key;\n        }\n      }\n\n      if (element.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = element;\n      }\n\n      let locals: t.Identifier[];\n      if (hasDecorators) {\n        let privateMethods: Array<\n          t.FunctionExpression | t.ArrowFunctionExpression\n        >;\n\n        let nameExpr: t.Expression;\n\n        if (isComputed) {\n          nameExpr = getComputedKeyMemoiser(\n            element.get(\"key\") as NodePath<t.Expression>,\n          );\n        } else if (key.type === \"PrivateName\") {\n          nameExpr = t.stringLiteral(key.id.name);\n        } else if (key.type === \"Identifier\") {\n          nameExpr = t.stringLiteral(key.name);\n        } else {\n          nameExpr = t.cloneNode(key as t.Expression);\n        }\n\n        if (kind === ACCESSOR) {\n          const { value } = element.node as t.ClassAccessorProperty;\n\n          const params: t.Expression[] =\n            (process.env.BABEL_8_BREAKING || version === \"2023-11\") && isStatic\n              ? []\n              : [t.thisExpression()];\n\n          if (value) {\n            params.push(t.cloneNode(value));\n          }\n\n          const newId = generateClassPrivateUid();\n          const newFieldInitId = generateLetUidIdentifier(\n            scopeParent,\n            `init_${name}`,\n          );\n          const newValue = t.callExpression(\n            t.cloneNode(newFieldInitId),\n            params,\n          );\n\n          const newField = generateClassProperty(newId, newValue, isStatic);\n          const [newPath] = element.replaceWith(newField);\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(newId, version);\n\n            const getId = generateLetUidIdentifier(scopeParent, `get_${name}`);\n            const setId = generateLetUidIdentifier(scopeParent, `set_${name}`);\n\n            addCallAccessorsFor(version, newPath, key, getId, setId, isStatic);\n\n            locals = [newFieldInitId, getId, setId];\n          } else {\n            addProxyAccessorsFor(\n              path.node.id,\n              newPath,\n              t.cloneNode(key),\n              t.isAssignmentExpression(key)\n                ? t.cloneNode(key.left as t.Identifier)\n                : t.cloneNode(key),\n              newId,\n              isComputed,\n              isStatic,\n              version,\n            );\n            locals = [newFieldInitId];\n          }\n        } else if (kind === FIELD) {\n          const initId = generateLetUidIdentifier(scopeParent, `init_${name}`);\n          const valuePath = (\n            element as NodePath<t.ClassProperty | t.ClassPrivateProperty>\n          ).get(\"value\");\n\n          const args: t.Expression[] =\n            (process.env.BABEL_8_BREAKING || version === \"2023-11\") && isStatic\n              ? []\n              : [t.thisExpression()];\n          if (valuePath.node) args.push(valuePath.node);\n\n          valuePath.replaceWith(t.callExpression(t.cloneNode(initId), args));\n\n          locals = [initId];\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(key, version);\n          }\n        } else if (isPrivate) {\n          const callId = generateLetUidIdentifier(scopeParent, `call_${name}`);\n          locals = [callId];\n\n          const replaceSupers = new ReplaceSupers({\n            constantSuper,\n            methodPath: element as NodePath<t.ClassPrivateMethod>,\n            objectRef: classIdLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classIdLocal,\n          });\n\n          replaceSupers.replace();\n\n          privateMethods = [\n            createFunctionExpressionFromPrivateMethod(\n              element.node as t.ClassPrivateMethod,\n            ),\n          ];\n\n          if (kind === GETTER || kind === SETTER) {\n            movePrivateAccessor(\n              element as NodePath<t.ClassPrivateMethod>,\n              t.cloneNode(key),\n              t.cloneNode(callId),\n              isStatic,\n            );\n          } else {\n            const node = element.node as t.ClassPrivateMethod;\n\n            // Unshift\n            path.node.body.body.unshift(\n              t.classPrivateProperty(key, t.cloneNode(callId), [], node.static),\n            );\n\n            decoratedPrivateMethods.add(key.id.name);\n\n            element.remove();\n          }\n        }\n\n        elementDecoratorInfo.push({\n          kind,\n          decoratorsArray,\n          decoratorsHaveThis,\n          name: nameExpr,\n          isStatic,\n          privateMethods,\n          locals,\n        });\n\n        if (element.node) {\n          element.node.decorators = null;\n        }\n      }\n\n      if (isComputed && computedKeyAssignments.length > 0) {\n        if (classDecorators && element.isClassProperty({ static: true })) {\n          // If the class is decorated, we don't insert computedKeyAssignments here\n          // because any non-static computed elements defined after it will be moved\n          // into the non-static class, so they will be evaluated before the key of\n          // this field. At this momemnt, its key must be either a constant expression\n          // or a uid reference which has been assigned _within_ the non-static class.\n        } else {\n          prependExpressionsToComputedKey(\n            computedKeyAssignments,\n            (kind === ACCESSOR\n              ? element.getNextSibling() // the transpiled getter of the accessor property\n              : element) as NodePath<ClassElementCanHaveComputedKeys>,\n          );\n          computedKeyAssignments = [];\n        }\n      }\n\n      if (\n        fieldInitializerExpressions.length > 0 &&\n        !isStatic &&\n        (kind === FIELD || kind === ACCESSOR)\n      ) {\n        prependExpressionsToFieldInitializer(\n          fieldInitializerExpressions,\n          element as NodePath<t.ClassProperty | t.ClassPrivateProperty>,\n        );\n        fieldInitializerExpressions = [];\n      }\n\n      if (\n        staticFieldInitializerExpressions.length > 0 &&\n        isStatic &&\n        (kind === FIELD || kind === ACCESSOR)\n      ) {\n        prependExpressionsToFieldInitializer(\n          staticFieldInitializerExpressions,\n          element as NodePath<t.ClassProperty | t.ClassPrivateProperty>,\n        );\n        staticFieldInitializerExpressions = [];\n      }\n\n      if (hasDecorators && version === \"2023-11\") {\n        if (kind === FIELD || kind === ACCESSOR) {\n          const initExtraId = generateLetUidIdentifier(\n            scopeParent,\n            `init_extra_${name}`,\n          );\n          locals.push(initExtraId);\n          const initExtraCall = t.callExpression(\n            t.cloneNode(initExtraId),\n            isStatic ? [] : [t.thisExpression()],\n          );\n          if (!isStatic) {\n            fieldInitializerExpressions.push(initExtraCall);\n          } else {\n            staticFieldInitializerExpressions.push(initExtraCall);\n          }\n        }\n      }\n    }\n  }\n\n  if (computedKeyAssignments.length > 0) {\n    const elements = path.get(\"body.body\");\n    let lastComputedElement: NodePath<ClassElementCanHaveComputedKeys>;\n    for (let i = elements.length - 1; i >= 0; i--) {\n      const path = elements[i];\n      const node = path.node as ClassElementCanHaveComputedKeys;\n      if (node.computed) {\n        if (classDecorators && t.isClassProperty(node, { static: true })) {\n          continue;\n        }\n        lastComputedElement = path as NodePath<ClassElementCanHaveComputedKeys>;\n        break;\n      }\n    }\n    if (lastComputedElement != null) {\n      appendExpressionsToComputedKey(\n        computedKeyAssignments,\n        lastComputedElement,\n      );\n      computedKeyAssignments = [];\n    } else {\n      // If there is no computed key, we will try to convert the first non-computed\n      // class element into a computed key and insert assignments there. This will\n      // be done after we handle the class elements split when the class is decorated.\n    }\n  }\n\n  if (fieldInitializerExpressions.length > 0) {\n    const isDerivedClass = !!path.node.superClass;\n    if (constructorPath) {\n      if (isDerivedClass) {\n        insertExpressionsAfterSuperCallAndOptimize(\n          fieldInitializerExpressions,\n          constructorPath,\n          protoInitLocal,\n        );\n      } else {\n        prependExpressionsToConstructor(\n          fieldInitializerExpressions,\n          constructorPath,\n        );\n      }\n    } else {\n      path.node.body.body.unshift(\n        createConstructorFromExpressions(\n          fieldInitializerExpressions,\n          isDerivedClass,\n        ),\n      );\n    }\n    fieldInitializerExpressions = [];\n  }\n\n  if (staticFieldInitializerExpressions.length > 0) {\n    path.node.body.body.push(\n      createStaticBlockFromExpressions(staticFieldInitializerExpressions),\n    );\n    staticFieldInitializerExpressions = [];\n  }\n\n  const sortedElementDecoratorInfo =\n    toSortedDecoratorInfo(elementDecoratorInfo);\n\n  const elementDecorations = generateDecorationExprs(\n    process.env.BABEL_8_BREAKING || version === \"2023-11\"\n      ? elementDecoratorInfo\n      : sortedElementDecoratorInfo,\n    version,\n  );\n\n  const elementLocals: t.Identifier[] = extractElementLocalAssignments(\n    sortedElementDecoratorInfo,\n  );\n\n  if (protoInitLocal) {\n    elementLocals.push(protoInitLocal);\n  }\n\n  if (staticInitLocal) {\n    elementLocals.push(staticInitLocal);\n  }\n\n  const classLocals: t.Identifier[] = [];\n  let classInitInjected = false;\n  const classInitCall =\n    classInitLocal && t.callExpression(t.cloneNode(classInitLocal), []);\n\n  let originalClassPath = path;\n  const originalClass = path.node;\n\n  const staticClosures: t.AssignmentExpression[] = [];\n  if (classDecorators) {\n    classLocals.push(classIdLocal, classInitLocal);\n    const statics: (\n      | t.ClassProperty\n      | t.ClassPrivateProperty\n      | t.ClassPrivateMethod\n    )[] = [];\n    path.get(\"body.body\").forEach(element => {\n      // Static blocks cannot be compiled to \"instance blocks\", but we can inline\n      // them as IIFEs in the next property.\n      if (element.isStaticBlock()) {\n        if (hasInstancePrivateAccess(element, instancePrivateNames)) {\n          const staticBlockClosureId = memoiseExpression(\n            staticBlockToFunctionClosure(element.node),\n            \"staticBlock\",\n            staticClosures,\n          );\n          staticFieldInitializerExpressions.push(\n            t.callExpression(\n              t.memberExpression(staticBlockClosureId, t.identifier(\"call\")),\n              [t.thisExpression()],\n            ),\n          );\n        } else {\n          staticFieldInitializerExpressions.push(\n            staticBlockToIIFE(element.node),\n          );\n        }\n        element.remove();\n        return;\n      }\n\n      if (\n        (element.isClassProperty() || element.isClassPrivateProperty()) &&\n        element.node.static\n      ) {\n        const valuePath = (\n          element as NodePath<t.ClassProperty | t.ClassPrivateProperty>\n        ).get(\"value\");\n        if (hasInstancePrivateAccess(valuePath, instancePrivateNames)) {\n          const fieldValueClosureId = memoiseExpression(\n            fieldInitializerToClosure(valuePath.node),\n            \"fieldValue\",\n            staticClosures,\n          );\n          valuePath.replaceWith(\n            t.callExpression(\n              t.memberExpression(fieldValueClosureId, t.identifier(\"call\")),\n              [t.thisExpression()],\n            ),\n          );\n        }\n        if (staticFieldInitializerExpressions.length > 0) {\n          prependExpressionsToFieldInitializer(\n            staticFieldInitializerExpressions,\n            element,\n          );\n          staticFieldInitializerExpressions = [];\n        }\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      } else if (element.isClassPrivateMethod({ static: true })) {\n        // At this moment the element must not have decorators, so any private name\n        // within the element must come from either params or body\n        if (hasInstancePrivateAccess(element, instancePrivateNames)) {\n          const replaceSupers = new ReplaceSupers({\n            constantSuper,\n            methodPath: element,\n            objectRef: classIdLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classIdLocal,\n          });\n\n          replaceSupers.replace();\n\n          const privateMethodDelegateId = memoiseExpression(\n            createFunctionExpressionFromPrivateMethod(element.node),\n            element.get(\"key.id\").node.name,\n            staticClosures,\n          );\n\n          if (ignoreFunctionLength) {\n            element.node.params = [t.restElement(t.identifier(\"arg\"))];\n            element.node.body = t.blockStatement([\n              t.returnStatement(\n                t.callExpression(\n                  t.memberExpression(\n                    privateMethodDelegateId,\n                    t.identifier(\"apply\"),\n                  ),\n                  [t.thisExpression(), t.identifier(\"arg\")],\n                ),\n              ),\n            ]);\n          } else {\n            element.node.params = element.node.params.map((p, i) => {\n              if (t.isRestElement(p)) {\n                return t.restElement(t.identifier(\"arg\"));\n              } else {\n                return t.identifier(\"_\" + i);\n              }\n            });\n            element.node.body = t.blockStatement([\n              t.returnStatement(\n                t.callExpression(\n                  t.memberExpression(\n                    privateMethodDelegateId,\n                    t.identifier(\"apply\"),\n                  ),\n                  [t.thisExpression(), t.identifier(\"arguments\")],\n                ),\n              ),\n            ]);\n          }\n        }\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      }\n    });\n\n    if (statics.length > 0 || staticFieldInitializerExpressions.length > 0) {\n      const staticsClass = template.expression.ast`\n        class extends ${state.addHelper(\"identity\")} {}\n      ` as t.ClassExpression;\n      staticsClass.body.body = [\n        // Insert the original class to a computed key of the wrapper so that\n        // 1) they share the same function context with the wrapper class\n        // 2) the memoisation of static computed field is evaluated before they\n        //    are referenced in the wrapper class keys\n        // Note that any static elements of the wrapper class can not be accessed\n        // in the user land, so we don't have to remove the temporary class field.\n        t.classProperty(\n          t.toExpression(originalClass),\n          undefined,\n          undefined,\n          undefined,\n          /* computed */ true,\n          /* static */ true,\n        ),\n        ...statics,\n      ];\n\n      const constructorBody: t.Expression[] = [];\n\n      const newExpr = t.newExpression(staticsClass, []);\n\n      if (staticFieldInitializerExpressions.length > 0) {\n        constructorBody.push(...staticFieldInitializerExpressions);\n      }\n      if (classInitCall) {\n        classInitInjected = true;\n        constructorBody.push(classInitCall);\n      }\n      if (constructorBody.length > 0) {\n        constructorBody.unshift(\n          t.callExpression(t.super(), [t.cloneNode(classIdLocal)]),\n        );\n\n        // set isDerivedClass to false as we have already prepended super call\n        staticsClass.body.body.push(\n          createConstructorFromExpressions(\n            constructorBody,\n            /* isDerivedClass */ false,\n          ),\n        );\n      } else {\n        newExpr.arguments.push(t.cloneNode(classIdLocal));\n      }\n\n      const [newPath] = path.replaceWith(newExpr);\n\n      // update originalClassPath according to the new AST\n      originalClassPath = (\n        newPath.get(\"callee\").get(\"body\") as NodePath<t.ClassBody>\n      )\n        .get(\"body\")[0]\n        .get(\"key\");\n    }\n  }\n  if (!classInitInjected && classInitCall) {\n    path.node.body.body.push(\n      t.staticBlock([t.expressionStatement(classInitCall)]),\n    );\n  }\n\n  let { superClass } = originalClass;\n  if (\n    superClass &&\n    (process.env.BABEL_8_BREAKING ||\n      version === \"2023-11\" ||\n      version === \"2023-05\")\n  ) {\n    const id = path.scope.maybeGenerateMemoised(superClass);\n    if (id) {\n      originalClass.superClass = t.assignmentExpression(\"=\", id, superClass);\n      superClass = id;\n    }\n  }\n\n  const applyDecoratorWrapper = t.staticBlock([]);\n  originalClass.body.body.unshift(applyDecoratorWrapper);\n  const applyDecsBody = applyDecoratorWrapper.body;\n  if (computedKeyAssignments.length > 0) {\n    const elements = originalClassPath.get(\"body.body\");\n    let firstPublicElement: NodePath<t.ClassProperty | t.ClassMethod>;\n    for (const path of elements) {\n      if (\n        (path.isClassProperty() || path.isClassMethod()) &&\n        (path.node as t.ClassMethod).kind !== \"constructor\"\n      ) {\n        firstPublicElement = path;\n        break;\n      }\n    }\n    if (firstPublicElement != null) {\n      // Convert its key to a computed one to host the decorator evaluations.\n      convertToComputedKey(firstPublicElement);\n      prependExpressionsToComputedKey(\n        computedKeyAssignments,\n        firstPublicElement,\n      );\n    } else {\n      // When there is no public class elements, we inject a temporary computed\n      // field whose key will host the decorator evaluations. The field will be\n      // deleted immediately after it is defiend.\n      originalClass.body.body.unshift(\n        t.classProperty(\n          t.sequenceExpression([\n            ...computedKeyAssignments,\n            t.stringLiteral(\"_\"),\n          ]),\n          undefined,\n          undefined,\n          undefined,\n          /* computed */ true,\n          /* static */ true,\n        ),\n      );\n      applyDecsBody.push(\n        t.expressionStatement(\n          t.unaryExpression(\n            \"delete\",\n            t.memberExpression(t.thisExpression(), t.identifier(\"_\")),\n          ),\n        ),\n      );\n    }\n    computedKeyAssignments = [];\n  }\n\n  applyDecsBody.push(\n    t.expressionStatement(\n      createLocalsAssignment(\n        elementLocals,\n        classLocals,\n        elementDecorations,\n        classDecorationsId ?? t.arrayExpression(classDecorations),\n        t.numericLiteral(classDecorationsFlag),\n        needsInstancePrivateBrandCheck ? lastInstancePrivateName : null,\n        typeof className === \"object\" ? className : undefined,\n        t.cloneNode(superClass),\n        state,\n        version,\n      ),\n    ),\n  );\n  if (staticInitLocal) {\n    applyDecsBody.push(\n      t.expressionStatement(\n        t.callExpression(t.cloneNode(staticInitLocal), [t.thisExpression()]),\n      ),\n    );\n  }\n  if (staticClosures.length > 0) {\n    applyDecsBody.push(\n      ...staticClosures.map(expr => t.expressionStatement(expr)),\n    );\n  }\n\n  // When path is a ClassExpression, path.insertBefore will convert `path`\n  // into a SequenceExpression\n  path.insertBefore(classAssignments.map(expr => t.expressionStatement(expr)));\n\n  if (needsDeclaraionForClassBinding) {\n    path.insertBefore(\n      t.variableDeclaration(\"let\", [\n        t.variableDeclarator(t.cloneNode(classIdLocal)),\n      ]),\n    );\n  }\n\n  if (decoratedPrivateMethods.size > 0) {\n    checkPrivateMethodUpdateError(path, decoratedPrivateMethods);\n  }\n\n  // Recrawl the scope to make sure new identifiers are properly synced\n  path.scope.crawl();\n\n  return path;\n}\n\nfunction createLocalsAssignment(\n  elementLocals: t.Identifier[],\n  classLocals: t.Identifier[],\n  elementDecorations: t.ArrayExpression | t.Identifier,\n  classDecorations: t.ArrayExpression | t.Identifier,\n  classDecorationsFlag: t.NumericLiteral,\n  maybePrivateBrandName: t.PrivateName | null,\n  setClassName: t.Identifier | t.StringLiteral | undefined,\n  superClass: null | t.Expression,\n  state: PluginPass,\n  version: DecoratorVersionKind,\n) {\n  let lhs, rhs;\n  const args: t.Expression[] = [\n    setClassName\n      ? createSetFunctionNameCall(state, setClassName)\n      : t.thisExpression(),\n    classDecorations,\n    elementDecorations,\n  ];\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (version !== \"2023-11\") {\n      args.splice(1, 2, elementDecorations, classDecorations);\n    }\n    if (\n      version === \"2021-12\" ||\n      (version === \"2022-03\" && !state.availableHelper(\"applyDecs2203R\"))\n    ) {\n      lhs = t.arrayPattern([...elementLocals, ...classLocals]);\n      rhs = t.callExpression(\n        state.addHelper(version === \"2021-12\" ? \"applyDecs\" : \"applyDecs2203\"),\n        args,\n      );\n      return t.assignmentExpression(\"=\", lhs, rhs);\n    } else if (version === \"2022-03\") {\n      rhs = t.callExpression(state.addHelper(\"applyDecs2203R\"), args);\n    } else if (version === \"2023-01\") {\n      if (maybePrivateBrandName) {\n        args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n      }\n      rhs = t.callExpression(state.addHelper(\"applyDecs2301\"), args);\n    } else if (version === \"2023-05\") {\n      if (\n        maybePrivateBrandName ||\n        superClass ||\n        classDecorationsFlag.value !== 0\n      ) {\n        args.push(classDecorationsFlag);\n      }\n      if (maybePrivateBrandName) {\n        args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n      } else if (superClass) {\n        args.push(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      }\n      if (superClass) args.push(superClass);\n      rhs = t.callExpression(state.addHelper(\"applyDecs2305\"), args);\n    }\n  }\n  if (process.env.BABEL_8_BREAKING || version === \"2023-11\") {\n    if (\n      maybePrivateBrandName ||\n      superClass ||\n      classDecorationsFlag.value !== 0\n    ) {\n      args.push(classDecorationsFlag);\n    }\n    if (maybePrivateBrandName) {\n      args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n    } else if (superClass) {\n      args.push(t.unaryExpression(\"void\", t.numericLiteral(0)));\n    }\n    if (superClass) args.push(superClass);\n    rhs = t.callExpression(state.addHelper(\"applyDecs2311\"), args);\n  }\n\n  // optimize `{ c: [classLocals] } = applyDecsHelper(...)` to\n  // `[classLocals] = applyDecsHelper(...).c`\n  if (elementLocals.length > 0) {\n    if (classLocals.length > 0) {\n      lhs = t.objectPattern([\n        t.objectProperty(t.identifier(\"e\"), t.arrayPattern(elementLocals)),\n        t.objectProperty(t.identifier(\"c\"), t.arrayPattern(classLocals)),\n      ]);\n    } else {\n      lhs = t.arrayPattern(elementLocals);\n      rhs = t.memberExpression(rhs, t.identifier(\"e\"), false, false);\n    }\n  } else {\n    // invariant: classLocals.length > 0\n    lhs = t.arrayPattern(classLocals);\n    rhs = t.memberExpression(rhs, t.identifier(\"c\"), false, false);\n  }\n\n  return t.assignmentExpression(\"=\", lhs, rhs);\n}\n\nfunction isProtoKey(\n  node: t.Identifier | t.StringLiteral | t.BigIntLiteral | t.NumericLiteral,\n) {\n  return node.type === \"Identifier\"\n    ? node.name === \"__proto__\"\n    : node.value === \"__proto__\";\n}\n\nfunction isDecorated(node: t.Class | ClassDecoratableElement) {\n  return node.decorators && node.decorators.length > 0;\n}\n\nfunction shouldTransformElement(node: ClassElement) {\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      return true;\n    case \"ClassMethod\":\n    case \"ClassProperty\":\n    case \"ClassPrivateMethod\":\n    case \"ClassPrivateProperty\":\n      return isDecorated(node);\n    default:\n      return false;\n  }\n}\n\nfunction shouldTransformClass(node: t.Class) {\n  return isDecorated(node) || node.body.body.some(shouldTransformElement);\n}\n\n// Todo: unify name references logic with helper-function-name\nfunction NamedEvaluationVisitoryFactory(\n  isAnonymous: (path: NodePath) => boolean,\n  visitor: (\n    path: NodePath,\n    state: PluginPass,\n    name:\n      | string\n      | t.Identifier\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral,\n  ) => void,\n) {\n  function handleComputedProperty(\n    propertyPath: NodePath<\n      t.ObjectProperty | t.ClassProperty | t.ClassAccessorProperty\n    >,\n    key: t.Expression,\n    state: PluginPass,\n  ): t.StringLiteral | t.Identifier {\n    switch (key.type) {\n      case \"StringLiteral\":\n        return t.stringLiteral(key.value);\n      case \"NumericLiteral\":\n      case \"BigIntLiteral\": {\n        const keyValue = key.value + \"\";\n        propertyPath.get(\"key\").replaceWith(t.stringLiteral(keyValue));\n        return t.stringLiteral(keyValue);\n      }\n      default: {\n        const ref = propertyPath.scope.maybeGenerateMemoised(key);\n        propertyPath\n          .get(\"key\")\n          .replaceWith(\n            t.assignmentExpression(\n              \"=\",\n              ref,\n              createToPropertyKeyCall(state, key),\n            ),\n          );\n        return t.cloneNode(ref);\n      }\n    }\n  }\n  return {\n    VariableDeclarator(path, state) {\n      const id = path.node.id;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"init\"));\n        if (isAnonymous(initializer)) {\n          const name = id.name;\n          visitor(initializer, state, name);\n        }\n      }\n    },\n    AssignmentExpression(path, state) {\n      const id = path.node.left;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"right\"));\n        if (isAnonymous(initializer)) {\n          switch (path.node.operator) {\n            case \"=\":\n            case \"&&=\":\n            case \"||=\":\n            case \"??=\":\n              visitor(initializer, state, id.name);\n          }\n        }\n      }\n    },\n    AssignmentPattern(path, state) {\n      const id = path.node.left;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"right\"));\n        if (isAnonymous(initializer)) {\n          const name = id.name;\n          visitor(initializer, state, name);\n        }\n      }\n    },\n    // We listen on ObjectExpression so that we don't have to visit\n    // the object properties under object patterns\n    ObjectExpression(path, state) {\n      for (const propertyPath of path.get(\"properties\")) {\n        const { node } = propertyPath;\n        if (node.type !== \"ObjectProperty\") continue;\n        const id = node.key;\n        const initializer = skipTransparentExprWrappers(\n          propertyPath.get(\"value\"),\n        );\n        if (isAnonymous(initializer)) {\n          if (!node.computed) {\n            // 13.2.5.5 RS: PropertyDefinitionEvaluation\n            if (!isProtoKey(id as t.StringLiteral | t.Identifier)) {\n              if (id.type === \"Identifier\") {\n                visitor(initializer, state, id.name);\n              } else {\n                const className = t.stringLiteral(\n                  (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                    .value + \"\",\n                );\n                visitor(initializer, state, className);\n              }\n            }\n          } else {\n            const ref = handleComputedProperty(\n              propertyPath as NodePath<t.ObjectProperty>,\n              // The key of a computed object property must not be a private name\n              id as t.Expression,\n              state,\n            );\n            visitor(initializer, state, ref);\n          }\n        }\n      }\n    },\n    ClassPrivateProperty(path, state) {\n      const { node } = path;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        const className = t.stringLiteral(\"#\" + node.key.id.name);\n        visitor(initializer, state, className);\n      }\n    },\n    ClassAccessorProperty(path, state) {\n      const { node } = path;\n      const id = node.key;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        if (!node.computed) {\n          if (id.type === \"Identifier\") {\n            visitor(initializer, state, id.name);\n          } else if (id.type === \"PrivateName\") {\n            const className = t.stringLiteral(\"#\" + id.id.name);\n            visitor(initializer, state, className);\n          } else {\n            const className = t.stringLiteral(\n              (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                .value + \"\",\n            );\n            visitor(initializer, state, className);\n          }\n        } else {\n          const ref = handleComputedProperty(\n            path,\n            // The key of a computed accessor property must not be a private name\n            id as t.Expression,\n            state,\n          );\n          visitor(initializer, state, ref);\n        }\n      }\n    },\n    ClassProperty(path, state) {\n      const { node } = path;\n      const id = node.key;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        if (!node.computed) {\n          if (id.type === \"Identifier\") {\n            visitor(initializer, state, id.name);\n          } else {\n            const className = t.stringLiteral(\n              (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                .value + \"\",\n            );\n            visitor(initializer, state, className);\n          }\n        } else {\n          const ref = handleComputedProperty(path, id, state);\n          visitor(initializer, state, ref);\n        }\n      }\n    },\n  } satisfies Visitor<PluginPass>;\n}\n\nfunction isDecoratedAnonymousClassExpression(path: NodePath) {\n  return (\n    path.isClassExpression({ id: null }) && shouldTransformClass(path.node)\n  );\n}\n\nfunction generateLetUidIdentifier(scope: Scope, name: string) {\n  const id = scope.generateUidIdentifier(name);\n  scope.push({ id, kind: \"let\" });\n  return t.cloneNode(id);\n}\n\nexport default function (\n  { assertVersion, assumption }: PluginAPI,\n  { loose }: Options,\n  version: DecoratorVersionKind,\n  inherits: PluginObject[\"inherits\"],\n): PluginObject {\n  if (process.env.BABEL_8_BREAKING) {\n    assertVersion(REQUIRED_VERSION(\"^7.21.0\"));\n  } else {\n    if (\n      version === \"2023-11\" ||\n      version === \"2023-05\" ||\n      version === \"2023-01\"\n    ) {\n      assertVersion(REQUIRED_VERSION(\"^7.21.0\"));\n    } else if (version === \"2021-12\") {\n      assertVersion(REQUIRED_VERSION(\"^7.16.0\"));\n    } else {\n      assertVersion(REQUIRED_VERSION(\"^7.19.0\"));\n    }\n  }\n\n  const VISITED = new WeakSet<NodePath>();\n  const constantSuper = assumption(\"constantSuper\") ?? loose;\n  const ignoreFunctionLength = assumption(\"ignoreFunctionLength\") ?? loose;\n\n  const namedEvaluationVisitor: Visitor<PluginPass> =\n    NamedEvaluationVisitoryFactory(\n      isDecoratedAnonymousClassExpression,\n      visitClass,\n    );\n\n  function visitClass(\n    path: NodePath<t.Class>,\n    state: PluginPass,\n    className: string | t.Identifier | t.StringLiteral | undefined,\n  ) {\n    if (VISITED.has(path)) return;\n    const { node } = path;\n    className ??= node.id?.name;\n    const newPath = transformClass(\n      path,\n      state,\n      constantSuper,\n      ignoreFunctionLength,\n      className,\n      namedEvaluationVisitor,\n      version,\n    );\n    if (newPath) {\n      VISITED.add(newPath);\n      return;\n    }\n    VISITED.add(path);\n  }\n\n  return {\n    name: \"proposal-decorators\",\n    inherits: inherits,\n\n    visitor: {\n      ExportDefaultDeclaration(path, state) {\n        const { declaration } = path.node;\n        if (\n          declaration?.type === \"ClassDeclaration\" &&\n          // When compiling class decorators we need to replace the class\n          // binding, so we must split it in two separate declarations.\n          isDecorated(declaration)\n        ) {\n          const isAnonymous = !declaration.id;\n          const updatedVarDeclarationPath = splitExportDeclaration(\n            path,\n          ) as unknown as NodePath<t.ClassDeclaration>;\n          if (isAnonymous) {\n            visitClass(\n              updatedVarDeclarationPath,\n              state,\n              t.stringLiteral(\"default\"),\n            );\n          }\n        }\n      },\n      ExportNamedDeclaration(path) {\n        const { declaration } = path.node;\n        if (\n          declaration?.type === \"ClassDeclaration\" &&\n          // When compiling class decorators we need to replace the class\n          // binding, so we must split it in two separate declarations.\n          isDecorated(declaration)\n        ) {\n          splitExportDeclaration(path);\n        }\n      },\n\n      Class(path, state) {\n        visitClass(path, state, undefined);\n      },\n\n      ...namedEvaluationVisitor,\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]}