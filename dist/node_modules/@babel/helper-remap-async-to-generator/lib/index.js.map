{"version":3,"file":"index.js","names":["_helperWrapFunction","require","_helperAnnotateAsPure","_helperEnvironmentVisitor","_core","_core$types","types","callExpression","cloneNode","isIdentifier","isThisExpression","yieldExpression","awaitVisitor","traverse","visitors","merge","ArrowFunctionExpression","path","skip","AwaitExpression","_ref","wrapAwait","argument","get","replaceWith","node","_default","helpers","noNewArrows","ignoreFunctionLength","isIIFE","checkIsIIFE","async","generator","wrapAsync","isProperty","isObjectMethod","isClassMethod","parentPath","isObjectProperty","isClassProperty","isExpression","isCallExpression","callee","isMemberExpression","property","name","bindCall","arguments","length"],"sources":["../src/index.ts"],"sourcesContent":["/* @noflow */\n\nimport type { NodePath } from \"@babel/traverse\";\nimport wrapFunction from \"@babel/helper-wrap-function\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport { traverse, types as t } from \"@babel/core\";\nconst {\n  callExpression,\n  cloneNode,\n  isIdentifier,\n  isThisExpression,\n  yieldExpression,\n} = t;\n\nconst awaitVisitor = traverse.visitors.merge<{ wrapAwait: t.Expression }>([\n  {\n    ArrowFunctionExpression(path) {\n      path.skip();\n    },\n\n    AwaitExpression(path, { wrapAwait }) {\n      const argument = path.get(\"argument\");\n\n      path.replaceWith(\n        yieldExpression(\n          wrapAwait\n            ? callExpression(cloneNode(wrapAwait), [argument.node])\n            : argument.node,\n        ),\n      );\n    },\n  },\n  environmentVisitor,\n]);\n\nexport default function (\n  path: NodePath<t.Function>,\n  helpers: {\n    wrapAsync: t.Expression;\n    wrapAwait?: t.Expression;\n  },\n  noNewArrows?: boolean,\n  ignoreFunctionLength?: boolean,\n) {\n  path.traverse(awaitVisitor, {\n    wrapAwait: helpers.wrapAwait,\n  });\n\n  const isIIFE = checkIsIIFE(path);\n\n  path.node.async = false;\n  path.node.generator = true;\n\n  wrapFunction(\n    path,\n    cloneNode(helpers.wrapAsync),\n    noNewArrows,\n    ignoreFunctionLength,\n  );\n\n  const isProperty =\n    path.isObjectMethod() ||\n    path.isClassMethod() ||\n    path.parentPath.isObjectProperty() ||\n    path.parentPath.isClassProperty();\n\n  if (!isProperty && !isIIFE && path.isExpression()) {\n    annotateAsPure(path);\n  }\n\n  function checkIsIIFE(path: NodePath) {\n    if (path.parentPath.isCallExpression({ callee: path.node })) {\n      return true;\n    }\n\n    // try to catch calls to Function#bind, as emitted by arrowFunctionToExpression in spec mode\n    // this may also catch .bind(this) written by users, but does it matter? ðŸ¤”\n    const { parentPath } = path;\n    if (\n      parentPath.isMemberExpression() &&\n      isIdentifier(parentPath.node.property, { name: \"bind\" })\n    ) {\n      const { parentPath: bindCall } = parentPath;\n\n      // (function () { ... }).bind(this)()\n\n      return (\n        // first, check if the .bind is actually being called\n        bindCall.isCallExpression() &&\n        // and whether its sole argument is 'this'\n        bindCall.node.arguments.length === 1 &&\n        isThisExpression(bindCall.node.arguments[0]) &&\n        // and whether the result of the .bind(this) is being called\n        bindCall.parentPath.isCallExpression({ callee: bindCall.node })\n      );\n    }\n\n    return false;\n  }\n}\n"],"mappings":"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","ignoreList":[]}