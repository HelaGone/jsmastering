{"version":3,"file":"option-assertions.js","names":["_helperCompilationTargets","data","require","_options","msg","loc","type","concat","parent","name","index","JSON","stringify","Error","access","assertRootMode","value","undefined","assertSourceMaps","assertCompact","assertSourceType","assertCallerMetadata","obj","assertObject","_i","_Object$keys","Object","keys","length","prop","propLoc","assertInputSourceMap","_typeof","assertString","assertFunction","assertBoolean","Array","isArray","assertArray","assertIgnoreList","arr","forEach","item","i","assertIgnoreItem","RegExp","assertConfigApplicableTest","checkValidTest","assertConfigFileSearch","assertBabelrcSearch","assertPluginList","assertPluginItem","assertPluginTarget","opts","assertTargets","isBrowsersQueryValid","browsersLoc","esmodulesLoc","assertBrowsersList","browsers","esmodules","_i2","_Object$keys2","key","val","subLoc","hasOwnProperty","call","TargetNames","validTargets","join","assertBrowserVersion","Math","round","assertAssumptions","root","inPreset","source","_i3","_Object$keys3","assumptionsNames","has"],"sources":["../../../src/config/validation/option-assertions.ts"],"sourcesContent":["import {\n  isBrowsersQueryValid,\n  TargetNames,\n} from \"@babel/helper-compilation-targets\";\n\nimport type {\n  ConfigFileSearch,\n  BabelrcSearch,\n  IgnoreList,\n  IgnoreItem,\n  PluginList,\n  PluginItem,\n  PluginTarget,\n  ConfigApplicableTest,\n  SourceMapsOption,\n  SourceTypeOption,\n  CompactOption,\n  RootInputSourceMapOption,\n  NestingPath,\n  CallerMetadata,\n  RootMode,\n  TargetsListOrObject,\n  AssumptionName,\n} from \"./options.ts\";\n\nimport { assumptionsNames } from \"./options.ts\";\n\nexport type { RootPath } from \"./options.ts\";\n\nexport type ValidatorSet = {\n  [name: string]: Validator<any>;\n};\n\nexport type Validator<T> = (loc: OptionPath, value: unknown) => T;\n\nexport function msg(loc: NestingPath | GeneralPath): string {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n    default:\n      // @ts-expect-error should not happen when code is type checked\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\n\nexport function access(loc: GeneralPath, name: string | number): AccessPath {\n  return {\n    type: \"access\",\n    name,\n    parent: loc,\n  };\n}\n\nexport type OptionPath = Readonly<{\n  type: \"option\";\n  name: string;\n  parent: NestingPath;\n}>;\ntype AccessPath = Readonly<{\n  type: \"access\";\n  name: string | number;\n  parent: GeneralPath;\n}>;\ntype GeneralPath = OptionPath | AccessPath;\n\nexport function assertRootMode(\n  loc: OptionPath,\n  value: unknown,\n): RootMode | void {\n  if (\n    value !== undefined &&\n    value !== \"root\" &&\n    value !== \"upward\" &&\n    value !== \"upward-optional\"\n  ) {\n    throw new Error(\n      `${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`,\n    );\n  }\n  // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n  return value;\n}\n\nexport function assertSourceMaps(\n  loc: OptionPath,\n  value: unknown,\n): SourceMapsOption | void {\n  if (\n    value !== undefined &&\n    typeof value !== \"boolean\" &&\n    value !== \"inline\" &&\n    value !== \"both\"\n  ) {\n    throw new Error(\n      `${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`,\n    );\n  }\n  // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n  return value;\n}\n\nexport function assertCompact(\n  loc: OptionPath,\n  value: unknown,\n): CompactOption | void {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n  // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n  return value;\n}\n\nexport function assertSourceType(\n  loc: OptionPath,\n  value: unknown,\n): SourceTypeOption | void {\n  if (\n    value !== undefined &&\n    value !== \"module\" &&\n    value !== \"script\" &&\n    value !== \"unambiguous\"\n  ) {\n    throw new Error(\n      `${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`,\n    );\n  }\n  // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n  return value;\n}\n\nexport function assertCallerMetadata(\n  loc: OptionPath,\n  value: unknown,\n): CallerMetadata | undefined {\n  const obj = assertObject(loc, value);\n  if (obj) {\n    if (typeof obj.name !== \"string\") {\n      throw new Error(\n        `${msg(loc)} set but does not contain \"name\" property string`,\n      );\n    }\n\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n      if (\n        value != null &&\n        typeof value !== \"boolean\" &&\n        typeof value !== \"string\" &&\n        typeof value !== \"number\"\n      ) {\n        // NOTE(logan): I'm limiting the type here so that we can guarantee that\n        // the \"caller\" value will serialize to JSON nicely. We can always\n        // allow more complex structures later though.\n        throw new Error(\n          `${msg(\n            propLoc,\n          )} must be null, undefined, a boolean, a string, or a number.`,\n        );\n      }\n    }\n  }\n  // @ts-expect-error todo(flow->ts)\n  return value;\n}\n\nexport function assertInputSourceMap(\n  loc: OptionPath,\n  value: unknown,\n): RootInputSourceMapOption | void {\n  if (\n    value !== undefined &&\n    typeof value !== \"boolean\" &&\n    (typeof value !== \"object\" || !value)\n  ) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n  return value;\n}\n\nexport function assertString(loc: GeneralPath, value: unknown): string | void {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n  // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n  return value;\n}\n\nexport function assertFunction(\n  loc: GeneralPath,\n  value: unknown,\n): Function | void {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n  // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n  return value;\n}\n\nexport function assertBoolean(\n  loc: GeneralPath,\n  value: unknown,\n): boolean | void {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n  // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n  return value;\n}\n\nexport function assertObject(\n  loc: GeneralPath,\n  value: unknown,\n): { readonly [key: string]: unknown } | void {\n  if (\n    value !== undefined &&\n    (typeof value !== \"object\" || Array.isArray(value) || !value)\n  ) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n  // @ts-expect-error todo(flow->ts) value is still typed as unknown, also assert function typically should not return a value\n  return value;\n}\n\nexport function assertArray<T>(\n  loc: GeneralPath,\n  value: Array<T> | undefined | null,\n): ReadonlyArray<T> | undefined | null {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n  return value;\n}\n\nexport function assertIgnoreList(\n  loc: OptionPath,\n  value: unknown[] | undefined,\n): IgnoreList | void {\n  const arr = assertArray(loc, value);\n  arr?.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  // @ts-expect-error todo(flow->ts)\n  return arr;\n}\nfunction assertIgnoreItem(loc: GeneralPath, value: unknown): IgnoreItem {\n  if (\n    typeof value !== \"string\" &&\n    typeof value !== \"function\" &&\n    !(value instanceof RegExp)\n  ) {\n    throw new Error(\n      `${msg(\n        loc,\n      )} must be an array of string/Function/RegExp values, or undefined`,\n    );\n  }\n  return value as IgnoreItem;\n}\n\nexport function assertConfigApplicableTest(\n  loc: OptionPath,\n  value: unknown,\n): ConfigApplicableTest | void {\n  if (value === undefined) {\n    // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(\n          `${msg(access(loc, i))} must be a string/Function/RegExp.`,\n        );\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(\n      `${msg(loc)} must be a string/Function/RegExp, or an array of those`,\n    );\n  }\n  return value as ConfigApplicableTest;\n}\n\nfunction checkValidTest(value: unknown): value is string | Function | RegExp {\n  return (\n    typeof value === \"string\" ||\n    typeof value === \"function\" ||\n    value instanceof RegExp\n  );\n}\n\nexport function assertConfigFileSearch(\n  loc: OptionPath,\n  value: unknown,\n): ConfigFileSearch | void {\n  if (\n    value !== undefined &&\n    typeof value !== \"boolean\" &&\n    typeof value !== \"string\"\n  ) {\n    throw new Error(\n      `${msg(loc)} must be a undefined, a boolean, a string, ` +\n        `got ${JSON.stringify(value)}`,\n    );\n  }\n  // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n  return value;\n}\n\nexport function assertBabelrcSearch(\n  loc: OptionPath,\n  value: unknown,\n): BabelrcSearch | void {\n  if (value === undefined || typeof value === \"boolean\") {\n    // @ts-expect-error: TS can only narrow down the type when \"strictNullCheck\" is true\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(\n          `${msg(access(loc, i))} must be a string/Function/RegExp.`,\n        );\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(\n      `${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` +\n        `or an array of those, got ${JSON.stringify(value as any)}`,\n    );\n  }\n  return value as BabelrcSearch;\n}\n\nexport function assertPluginList(\n  loc: OptionPath,\n  value: unknown[] | null | undefined,\n): PluginList | void {\n  const arr = assertArray(loc, value);\n  if (arr) {\n    // Loop instead of using `.map` in order to preserve object identity\n    // for plugin array for use during config chain processing.\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n  return arr as any;\n}\nfunction assertPluginItem(loc: GeneralPath, value: unknown): PluginItem {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      const opts = value[1];\n      if (\n        opts !== undefined &&\n        opts !== false &&\n        (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)\n      ) {\n        throw new Error(\n          `${msg(access(loc, 1))} must be an object, false, or undefined`,\n        );\n      }\n    }\n    if (value.length === 3) {\n      const name = value[2];\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(\n          `${msg(access(loc, 2))} must be a string, or undefined`,\n        );\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  // @ts-expect-error todo(flow->ts)\n  return value;\n}\nfunction assertPluginTarget(loc: GeneralPath, value: unknown): PluginTarget {\n  if (\n    (typeof value !== \"object\" || !value) &&\n    typeof value !== \"string\" &&\n    typeof value !== \"function\"\n  ) {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n  return value;\n}\n\nexport function assertTargets(\n  loc: GeneralPath,\n  value: any,\n): TargetsListOrObject {\n  if (isBrowsersQueryValid(value)) return value;\n\n  if (typeof value !== \"object\" || !value || Array.isArray(value)) {\n    throw new Error(\n      `${msg(loc)} must be a string, an array of strings or an object`,\n    );\n  }\n\n  const browsersLoc = access(loc, \"browsers\");\n  const esmodulesLoc = access(loc, \"esmodules\");\n\n  assertBrowsersList(browsersLoc, value.browsers);\n  assertBoolean(esmodulesLoc, value.esmodules);\n\n  for (const key of Object.keys(value)) {\n    const val = value[key];\n    const subLoc = access(loc, key);\n\n    if (key === \"esmodules\") assertBoolean(subLoc, val);\n    else if (key === \"browsers\") assertBrowsersList(subLoc, val);\n    else if (!Object.hasOwn(TargetNames, key)) {\n      const validTargets = Object.keys(TargetNames).join(\", \");\n      throw new Error(\n        `${msg(\n          subLoc,\n        )} is not a valid target. Supported targets are ${validTargets}`,\n      );\n    } else assertBrowserVersion(subLoc, val);\n  }\n\n  return value;\n}\n\nfunction assertBrowsersList(loc: GeneralPath, value: unknown) {\n  if (value !== undefined && !isBrowsersQueryValid(value)) {\n    throw new Error(\n      `${msg(loc)} must be undefined, a string or an array of strings`,\n    );\n  }\n}\n\nfunction assertBrowserVersion(loc: GeneralPath, value: unknown) {\n  if (typeof value === \"number\" && Math.round(value) === value) return;\n  if (typeof value === \"string\") return;\n\n  throw new Error(`${msg(loc)} must be a string or an integer number`);\n}\n\nexport function assertAssumptions(\n  loc: GeneralPath,\n  value: { [key: string]: unknown },\n): { [name: string]: boolean } | void {\n  if (value === undefined) return;\n\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(`${msg(loc)} must be an object or undefined.`);\n  }\n\n  // todo(flow->ts): remove any\n  let root: any = loc;\n  do {\n    root = root.parent;\n  } while (root.type !== \"root\");\n  const inPreset = root.source === \"preset\";\n\n  for (const name of Object.keys(value)) {\n    const subLoc = access(loc, name);\n    if (!assumptionsNames.has(name as AssumptionName)) {\n      throw new Error(`${msg(subLoc)} is not a supported assumption.`);\n    }\n    if (typeof value[name] !== \"boolean\") {\n      throw new Error(`${msg(subLoc)} must be a boolean.`);\n    }\n    if (inPreset && value[name] === false) {\n      throw new Error(\n        `${msg(subLoc)} cannot be set to 'false' inside presets.`,\n      );\n    }\n  }\n\n  // @ts-expect-error todo(flow->ts)\n  return value;\n}\n"],"mappings":"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","ignoreList":[]}