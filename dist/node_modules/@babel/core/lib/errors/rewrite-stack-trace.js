"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginHiddenCallStack = beginHiddenCallStack;
exports.endHiddenCallStack = endHiddenCallStack;
exports.expectedError = expectedError;
exports.injectVirtualStackFrame = injectVirtualStackFrame;
var _Object$getOwnPropert;
var ErrorToString = Function.call.bind(Error.prototype.toString);
var SUPPORTED = !!Error.captureStackTrace && ((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : _Object$getOwnPropert.writable) === true;
var START_HIDING = "startHiding - secret - don't use this - v1";
var STOP_HIDING = "stopHiding - secret - don't use this - v1";
var expectedErrors = new WeakSet();
var virtualFrames = new WeakMap();
function CallSite(filename) {
  return Object.create({
    isNative: function isNative() {
      return false;
    },
    isConstructor: function isConstructor() {
      return false;
    },
    isToplevel: function isToplevel() {
      return true;
    },
    getFileName: function getFileName() {
      return filename;
    },
    getLineNumber: function getLineNumber() {
      return undefined;
    },
    getColumnNumber: function getColumnNumber() {
      return undefined;
    },
    getFunctionName: function getFunctionName() {
      return undefined;
    },
    getMethodName: function getMethodName() {
      return undefined;
    },
    getTypeName: function getTypeName() {
      return undefined;
    },
    toString: function toString() {
      return filename;
    }
  });
}
function injectVirtualStackFrame(error, filename) {
  if (!SUPPORTED) return;
  var frames = virtualFrames.get(error);
  if (!frames) virtualFrames.set(error, frames = []);
  frames.push(CallSite(filename));
  return error;
}
function expectedError(error) {
  if (!SUPPORTED) return;
  expectedErrors.add(error);
  return error;
}
function beginHiddenCallStack(fn) {
  if (!SUPPORTED) return fn;
  return Object.defineProperty(function () {
    setupPrepareStackTrace();
    return fn.apply(void 0, arguments);
  }, "name", {
    value: STOP_HIDING
  });
}
function endHiddenCallStack(fn) {
  if (!SUPPORTED) return fn;
  return Object.defineProperty(function () {
    return fn.apply(void 0, arguments);
  }, "name", {
    value: START_HIDING
  });
}
function setupPrepareStackTrace() {
  setupPrepareStackTrace = function setupPrepareStackTrace() {};
  var _Error$prepareStackTr = Error.prepareStackTrace,
    prepareStackTrace = _Error$prepareStackTr === void 0 ? defaultPrepareStackTrace : _Error$prepareStackTr;
  var MIN_STACK_TRACE_LIMIT = 50;
  Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT));
  Error.prepareStackTrace = function stackTraceRewriter(err, trace) {
    var newTrace = [];
    var isExpected = expectedErrors.has(err);
    var status = isExpected ? "hiding" : "unknown";
    for (var i = 0; i < trace.length; i++) {
      var name = trace[i].getFunctionName();
      if (name === START_HIDING) {
        status = "hiding";
      } else if (name === STOP_HIDING) {
        if (status === "hiding") {
          status = "showing";
          if (virtualFrames.has(err)) {
            var _newTrace;
            (_newTrace = newTrace).unshift.apply(_newTrace, _toConsumableArray(virtualFrames.get(err)));
          }
        } else if (status === "unknown") {
          newTrace = trace;
          break;
        }
      } else if (status !== "hiding") {
        newTrace.push(trace[i]);
      }
    }
    return prepareStackTrace(err, newTrace);
  };
}
function defaultPrepareStackTrace(err, trace) {
  if (trace.length === 0) return ErrorToString(err);
  return "".concat(ErrorToString(err), "\n    at ").concat(trace.join("\n    at "));
}
0 && 0;
//# sourceMappingURL=rewrite-stack-trace.js.map