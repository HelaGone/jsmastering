{"version":3,"file":"buffer.js","names":["Buffer","map","indentChar","_classCallCheck","_map","_buf","_str","_appendCount","_last","_queue","_queueCursor","_canMarkIdName","_indentChar","_fastIndentations","_position","line","column","_sourcePosition","identifierName","undefined","identifierNamePos","filename","i","push","repeat","_allocQueue","_createClass","key","value","queue","_pushQueue","char","cursor","length","item","_popQueue","Error","get","_flush","result","code","trimRight","decodedMap","getDecoded","__mergedMap","resultMap","Object","defineProperty","writable","rawMappings","mappings","getRawMappings","append","str","maybeNewline","_append","appendChar","_appendChar","sourcePosition","queueIndentation","queueCursor","sourcePos","fastIndentation","String","fromCharCode","_mark","len","position","charCodeAt","indexOf","last","_this$_map","mark","removeTrailingNewline","removeLastSemicolon","getLastChar","getNewlineCount","count","endsWithCharAndNewline","lastCp","hasContent","exactSource","loc","cb","source","prop","_normalizePosition","sourceWithOffset","columnOffset","withSource","pos","target","Math","max","getCurrentColumn","lastIndex","getCurrentLine","exports"],"sources":["../src/buffer.ts"],"sourcesContent":["import type SourceMap from \"./source-map.ts\";\nimport * as charcodes from \"charcodes\";\n\nexport type Pos = {\n  line: number;\n  column: number;\n};\nexport type Loc = {\n  start?: Pos;\n  end?: Pos;\n  filename?: string;\n};\ntype SourcePos = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  filename: string | undefined;\n};\ntype InternalSourcePos = SourcePos & { identifierNamePos: Pos };\n\ntype QueueItem = {\n  char: number;\n  repeat: number;\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: undefined; // Not used, it always undefined.\n  identifierNamePos: undefined; // Not used, it always undefined.\n  filename: string | undefined;\n};\n\nexport default class Buffer {\n  constructor(map: SourceMap | null, indentChar: string) {\n    this._map = map;\n    this._indentChar = indentChar;\n\n    for (let i = 0; i < 64; i++) {\n      this._fastIndentations.push(indentChar.repeat(i));\n    }\n\n    this._allocQueue();\n  }\n\n  _map: SourceMap = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _queue: QueueItem[] = [];\n  _queueCursor = 0;\n  _canMarkIdName = true;\n  _indentChar = \"\";\n  _fastIndentations: string[] = [];\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: InternalSourcePos = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\",\n      });\n    }\n  }\n\n  _pushQueue(\n    char: number,\n    repeat: number,\n    line: number | undefined,\n    column: number | undefined,\n    filename: string | undefined,\n  ) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n\n    this._queueCursor++;\n  }\n\n  _popQueue(): QueueItem {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      // Whatever trim is used here should not execute a regex against the\n      // source string since it may be arbitrarily large after all transformations\n      code: (this._buf + this._str).trimRight(),\n      // Decoded sourcemap is free to generate.\n      decodedMap: map?.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = map?.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: number): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (char === charcodes.lineFeed) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== charcodes.space && char !== charcodes.tab) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(\n      char,\n      1,\n      sourcePosition.line,\n      sourcePosition.column,\n      sourcePosition.filename,\n    );\n  }\n\n  /**\n   * Same as queue, but this indentation will never have a sourcemap marker.\n   */\n  queueIndentation(repeat: number): void {\n    if (repeat === 0) return;\n    this._pushQueue(-1, repeat, undefined, undefined, undefined);\n  }\n\n  _flush(): void {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item: QueueItem = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n\n  _appendChar(\n    char: number,\n    repeat: number,\n    sourcePos: InternalSourcePos,\n  ): void {\n    this._last = char;\n\n    if (char === -1) {\n      const fastIndentation = this._fastIndentations[repeat];\n      if (fastIndentation !== undefined) {\n        this._str += fastIndentation;\n      } else {\n        this._str +=\n          repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;\n      }\n    } else {\n      this._str +=\n        repeat > 1\n          ? String.fromCharCode(char).repeat(repeat)\n          : String.fromCharCode(char);\n    }\n\n    if (char !== charcodes.lineFeed) {\n      this._mark(\n        sourcePos.line,\n        sourcePos.column,\n        sourcePos.identifierName,\n        sourcePos.identifierNamePos,\n        sourcePos.filename,\n      );\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n\n  _append(\n    str: string,\n    sourcePos: InternalSourcePos,\n    maybeNewline: boolean,\n  ): void {\n    const len = str.length;\n    const position = this._position;\n\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, null, null, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  _mark(\n    line: number | undefined,\n    column: number | undefined,\n    identifierName: string | undefined,\n    identifierNamePos: Pos | undefined,\n    filename: string | undefined,\n  ): void {\n    this._map?.mark(\n      this._position,\n      line,\n      column,\n      identifierName,\n      identifierNamePos,\n      filename,\n    );\n  }\n\n  removeTrailingNewline(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.lineFeed\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.semicolon\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar(): number {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== charcodes.lineFeed) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === charcodes.lineFeed\n      ? count + 1\n      : count;\n  }\n\n  /**\n   * check if current _last + queue ends with newline, return the character before newline\n   */\n  endsWithCharAndNewline(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      // every element in queue is one-length whitespace string\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== charcodes.lineFeed) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n    // We assume that everything being matched is at most a single token plus some whitespace,\n    // which everything currently is, but otherwise we'd have to expand _last or check _buf.\n  }\n\n  hasContent(): boolean {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    // @ts-expect-error identifierName is not defined\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  /**\n   * Call a callback with a specific source location\n   */\n\n  withSource(prop: \"start\" | \"end\", loc: Loc, cb: () => void): void {\n    if (this._map) {\n      this.source(prop, loc);\n    }\n\n    cb();\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === charcodes.lineFeed) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine(): number {\n    let count = 0;\n\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === charcodes.lineFeed) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n}\n"],"mappings":"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","ignoreList":[]}