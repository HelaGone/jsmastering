{"version":3,"file":"printer.js","names":["_buffer","require","n","_t","generatorFunctions","isFunction","isStatement","isClassBody","isTSInterfaceBody","isTSEnumDeclaration","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","HAS_NEWLINE","HAS_NEWLINE_OR_BlOCK_COMMENT_END","needsParens","Printer","format","map","_classCallCheck","inForStatementInitCounter","_printStack","_indent","_indentRepeat","_insideAux","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","Set","_endsWithInteger","_endsWithWord","_lastCommentLine","_endsWithInnerRaw","_indentInnerComments","indent","style","length","_inputMap","_buf","_createClass","key","value","generate","ast","print","_maybeAddAuxComment","get","compact","concise","dedent","semicolon","force","arguments","undefined","_appendChar","_queue","rightBrace","node","minified","removeLastSemicolon","sourceWithOffset","loc","tokenChar","rightParens","space","_space","hasContent","lastCp","getLastChar","word","str","noLineTerminatorAfter","_maybePrintInnerComments","charCodeAt","endsWith","_append","number","isNonDecimalLiteral","secondChar","Number","isInteger","test","token","maybeNewline","lastChar","strFirst","char","newline","i","retainLines","getNewlineCount","j","_newline","endsWithCharAndNewline","removeTrailingNewline","exactSource","cb","_catchUp","source","prop","columnOffset","withSource","sourceIdentifierName","identifierName","pos","_canMarkIdName","sourcePosition","_sourcePosition","identifierNamePos","_maybeAddParen","_maybeIndent","append","_maybeAddParenChar","appendChar","queue","firstChar","queueIndentation","_getIndent","_shouldIndent","parenPushNewlineState","printed","len","cha","chaPost","catchUp","line","count","getCurrentLine","_loc$prop","printTerminatorless","parent","isLabel","terminatorState","trailingCommentsLineOffset","forceParens","_node$extra","_node$leadingComments","nodeType","type","oldConcise","_compact","printMethod","ReferenceError","concat","JSON","stringify","constructor","name","push","oldInAux","parenthesized","extra","shouldPrintParens","retainFunctionParens","leadingComments","parentType","callee","_printLeadingComments","bind","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","opts","_nodes$0$loc","startLine","start","newlineOpts","addNewlines","nextNodeStartLine","separator","statement","_printNewline","iterator","_node$trailingComment","trailingComments","_nextNode$loc","nextNode","printAndIndentOnComments","printBlock","body","lineOffset","innerComments","_printComments","comments","printInnerComments","hasSpace","printedCommentsCount","size","noIndentInnerCommentsHere","printSequence","_opts$indent","printList","items","commaSeparator","newLine","lastCommentLine","offset","_shouldPrintComment","ignore","has","add","shouldPrintComment","skipNewLines","noLineTerminator","isBlockComment","printNewLines","lastCharCode","val","adjustMultilineComment","_comment$loc","column","newlineRegex","RegExp","replace","indentSize","getCurrentColumn","repeat","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","end","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","Math","max","min","singleLine","shouldSkipNewline","properties","Object","assign","prototype","Noop","_default","exports"],"sources":["../src/printer.ts"],"sourcesContent":["import Buffer, { type Pos } from \"./buffer.ts\";\nimport type { Loc } from \"./buffer.ts\";\nimport * as n from \"./node/index.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumDeclaration,\n} from \"@babel/types\";\nimport type {\n  RecordAndTuplePluginOptions,\n  PipelineOperatorPluginOptions,\n} from \"@babel/parser\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport * as generatorFunctions from \"./generators/index.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport * as charCodes from \"charcodes\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nconst { needsParens } = n;\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  retainLines: boolean;\n  retainFunctionParens: boolean;\n  comments: boolean;\n  auxiliaryCommentBefore: string;\n  auxiliaryCommentAfter: string;\n  compact: boolean | \"auto\";\n  minified: boolean;\n  concise: boolean;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  recordAndTupleSyntaxType: RecordAndTuplePluginOptions[\"syntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodiesâ€™ topic references.\n   */\n  topicToken?: PipelineOperatorPluginOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface AddNewlinesOptions {\n  addNewlines(leading: boolean, node: t.Node): number;\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(format: Format, map: SourceMap) {\n    this.format = format;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n  }\n  declare _inputMap: TraceMap;\n\n  declare format: Format;\n  inForStatementInitCounter: number = 0;\n\n  declare _buf: Buffer;\n  _printStack: Array<t.Node> = [];\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _parenPushNewlineState: { printed: boolean } | null = null;\n  _noLineTerminator: boolean = false;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n\n  generate(ast: t.Node) {\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent--;\n  }\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n    } else {\n      this._queue(charCodes.semicolon);\n    }\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this._maybePrintInnerComments();\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (str.charCodeAt(0) === charCodes.slash && this.endsWith(charCodes.slash))\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, false);\n\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   */\n  token(str: string, maybeNewline = false): void {\n    this._maybePrintInnerComments();\n\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark &&\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (str === \"--\" ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo)) ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number): void {\n    this._maybePrintInnerComments();\n\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  withSource(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    cb: () => void,\n  ): void {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeAddParen(str);\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _queue(char: number) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  _maybeAddParenChar(char: number): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    if (char === charCodes.space) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    if (char !== charCodes.lineFeed) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _maybeAddParen(str: string): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    const len = str.length;\n\n    let i;\n    for (i = 0; i < len && str.charCodeAt(i) === charCodes.space; i++) continue;\n    if (i === len) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    const cha = str.charCodeAt(i);\n    if (cha !== charCodes.lineFeed) {\n      if (\n        // This is not a comment (it doesn't start with /)\n        cha !== charCodes.slash ||\n        // This is not a comment (it's a / operator)\n        i + 1 === len\n      ) {\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str.charCodeAt(i + 1);\n\n      if (chaPost === charCodes.asterisk) {\n        // This is a block comment\n        return;\n      } else if (chaPost !== charCodes.slash) {\n        // This is neither a block comment, nor a line comment.\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const line = loc?.[prop]?.line;\n    if (line != null) {\n      const count = line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node, parent: t.Node, isLabel: boolean) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n    } else {\n      const terminatorState = {\n        printed: false,\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n      /**\n       * Print an ending parentheses if a starting one has been printed.\n       */\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.token(\")\");\n      }\n    }\n  }\n\n  print(\n    node: t.Node | null,\n    parent?: t.Node,\n    noLineTerminatorAfter?: boolean,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n    forceParens?: boolean,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          // removed\n          | \"Noop\"\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    const parenthesized = node.extra?.parenthesized as boolean | undefined;\n    let shouldPrintParens =\n      forceParens ||\n      (parenthesized &&\n        format.retainFunctionParens &&\n        nodeType === \"FunctionExpression\") ||\n      needsParens(node, parent, this._printStack);\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      const parentType = parent?.type;\n      switch (parentType) {\n        case \"ExpressionStatement\":\n        case \"VariableDeclarator\":\n        case \"AssignmentExpression\":\n        case \"ReturnStatement\":\n          break;\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n        case \"NewExpression\":\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      this._endsWithInnerRaw = false;\n    }\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    // end\n    this._printStack.pop();\n\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DecimalLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: Array<t.Node> | undefined | null,\n    parent: t.Node,\n    opts: PrintJoinOptions = {},\n  ) {\n    if (!nodes?.length) return;\n\n    let { indent } = opts;\n\n    if (indent == null && this.format.retainLines) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      addNewlines: opts.addNewlines,\n      nextNodeStartLine: 0,\n    };\n\n    const separator = opts.separator ? opts.separator.bind(this) : null;\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (opts.statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n\n      opts.iterator?.(node, i);\n\n      if (i < len - 1) separator?.();\n\n      if (opts.statement) {\n        if (!node.trailingComments?.length) {\n          this._lastCommentLine = 0;\n        }\n\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node, parent: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments() {\n    if (this._endsWithInnerRaw) this.printInnerComments();\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments() {\n    const node = this._printStack[this._printStack.length - 1];\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(COMMENT_TYPE.INNER, comments, node);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    parent: t.Node,\n    opts: PrintSequenceOptions = {},\n  ) {\n    opts.statement = true;\n    opts.indent ??= false;\n    this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items: t.Node[], parent: t.Node, opts: PrintListOptions = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    const format = this.format;\n\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (format.retainLines || format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(comment: t.Comment): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      const { _parenPushNewlineState } = this;\n      if (\n        _parenPushNewlineState?.printed === false &&\n        HAS_NEWLINE.test(comment.value)\n      ) {\n        this.token(\"(\");\n        this.indent();\n        _parenPushNewlineState.printed = true;\n      }\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this.format.concise) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines\n            ? 0\n            : this._buf.getCurrentColumn();\n\n          if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid creating //* comments\n    if (this.endsWith(charCodes.slash)) this._space();\n\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node,\n    lineOffset: number = 0,\n  ) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const maybeNewline = this._noLineTerminator\n      ? function () {}\n      : this.newline.bind(this);\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine != commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(\n              Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n            );\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumDeclaration(parent);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent, { body: node }))\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 has Noop print method\n  Printer.prototype.Noop = function Noop(this: Printer) {};\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer) {\n  this.token(\",\");\n  this.space();\n}\n"],"mappings":"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","ignoreList":[]}