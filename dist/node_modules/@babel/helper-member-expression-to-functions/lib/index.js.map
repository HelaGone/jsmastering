{"version":3,"file":"index.js","names":["willPathCastToBoolean","path","maybeWrapped","node","parentPath","isLogicalExpression","_parentPath$node","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","LOGICAL_OPERATORS","_t__namespace","arrowFunctionExpression","assignmentExpression","binaryExpression","booleanLiteral","callExpression","cloneNode","conditionalExpression","identifier","isMemberExpression","isOptionalCallExpression","isOptionalMemberExpression","isUpdateExpression","logicalExpression","memberExpression","nullLiteral","optionalCallExpression","optionalMemberExpression","sequenceExpression","updateExpression","AssignmentMemoiser","_classCallCheck","_map","WeakMap","_createClass","key","value","has","get","record","count","set","toNonOptional","base","property","computed","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","concat","_toConsumableArray","arguments","isInDetachedTree","isProgram","_path","container","listKey","parentNode","handle","memoise","member","noDocumentAll","parent","endPath","find","_ref","isPattern","willEndPathCastToBoolean","rootParentPath","argument","buildCodeFrameError","isAssignment","isAssignmentExpression","left","isDeleteOperation","isPrivateName","startingOptional","Error","type","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","isOptionalCall","parentIsCall","isCallExpression","optionalCall","call","boundGet","handleAssignment","regular","current","endParentPath","_regular","replacementPath","baseMemoised","nonNullishCheck","buildUndefinedNode","nullishCheck","endParent","simpleSet","prefix","ref","generateUidIdentifierBasedOnNode","push","id","seq","ref2","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","isTaggedTemplateExpression","state","_parentPath$node2","operatorTrunc","slice","includes","memberExpressionToFunctions","visitor","traverse","Object","assign","memoiser"],"sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-transform-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import type { NodePath, Visitor } from \"@babel/traverse\";\nimport {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  updateExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util.ts\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<t.Expression, { count: number; value: t.Identifier }>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key: t.Expression) {\n    return this._map.has(key);\n  }\n\n  get(key: t.Expression) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key: t.Expression, value: t.Identifier, count: number) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(\n  path: NodePath<t.Expression>,\n  base: t.Expression,\n): t.Expression {\n  const { node } = path;\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      // object must be a conditional expression because the optional private access in object has been transformed\n      const object = callee.node.object as t.ConditionalExpression;\n      const context = path.scope.maybeGenerateMemoised(object);\n      callee\n        .get(\"object\")\n        .replaceWith(assignmentExpression(\"=\", context, object));\n\n      return callExpression(memberExpression(base, identifier(\"call\")), [\n        context,\n        ...path.node.arguments,\n      ]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path: NodePath) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (\n        container !==\n        // @ts-expect-error listKey must be a valid parent node key\n        parentNode[listKey]\n      ) {\n        return true;\n      }\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\ntype Member = NodePath<t.OptionalMemberExpression | t.MemberExpression>;\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(this: HandlerState, member: Member, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent }) => {\n        if (isOptionalMemberExpression(parent)) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (isOptionalCallExpression(parent)) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      }) as NodePath<t.OptionalMemberExpression>;\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unnecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (rootParentPath.isUpdateExpression({ argument: node })) {\n        throw member.buildCodeFrameError(`can't handle update expression`);\n      }\n      const isAssignment = rootParentPath.isAssignmentExpression({\n        left: endPath.node,\n      });\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional: NodePath<t.Expression> = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n      const startingNode = startingOptional.isOptionalMemberExpression()\n        ? // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n          startingOptional.node.object\n        : // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n          startingOptional.node.callee;\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // here we use a function to wrap `parentIsOptionalCall` to get type\n      // for parent, do not use it anywhere else\n      // See https://github.com/microsoft/TypeScript/issues/10421\n      const isOptionalCall = (\n        parent: t.Node,\n      ): parent is t.OptionalCallExpression => parentIsOptionalCall;\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (isOptionalCall(parent)) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else if (\n        (process.env.BABEL_8_BREAKING || this.delete) &&\n        parentPath.isUnaryExpression({ operator: \"delete\" })\n      ) {\n        parentPath.replaceWith(this.delete(member));\n      } else if (parentPath.isAssignmentExpression()) {\n        // `a?.#b = c` to `(a == null ? void 0 : a.#b = c)`\n        handleAssignment(this, member, parentPath);\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular: t.Expression = member.node;\n      for (let current: NodePath = member; current !== endPath; ) {\n        const parentPath = current.parentPath as NodePath<t.Expression>;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (\n          parentPath === endPath &&\n          isOptionalCall(parent) &&\n          parent.optional\n        ) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context: t.Identifier;\n      const endParentPath = endPath.parentPath as NodePath<t.Expression>;\n      if (\n        isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = assignmentExpression(\n            \"=\",\n            context,\n            // object must not be Super when `context` is an identifier\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            object as t.Expression,\n          );\n        }\n      }\n\n      let replacementPath: NodePath = endPath;\n      if (isDeleteOperation || isAssignment) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? assignmentExpression(\n            \"=\",\n            // When base needs memoised, the baseRef must be an identifier\n            cloneNode(baseRef as t.Identifier),\n            cloneNode(startingNode),\n          )\n        : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\n            \"&&\",\n            binaryExpression(\"!==\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"!==\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\n            \"||\",\n            binaryExpression(\"===\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"===\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node as t.OptionalCallExpression;\n        endParentPath.replaceWith(\n          optionalCallExpression(\n            optionalMemberExpression(\n              endParent.callee,\n              identifier(\"call\"),\n              false,\n              true,\n            ),\n            [cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (ref = _get(MEMBER), ref2 = ref++, ref)), ref2\n    // ++MEMBER   ->   _set(MEMBER, (ref = _get(MEMBER), ++ref))\n    if (isUpdateExpression(parent, { argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const ref = scope.generateUidIdentifierBasedOnNode(node);\n      scope.push({ id: ref });\n\n      const seq: t.Expression[] = [\n        // ref = _get(MEMBER)\n        assignmentExpression(\"=\", cloneNode(ref), this.get(member)),\n      ];\n\n      if (prefix) {\n        seq.push(updateExpression(operator, cloneNode(ref), prefix));\n\n        // (ref = _get(MEMBER), ++ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(this.set(member, value));\n\n        return;\n      } else {\n        const ref2 = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref2 });\n\n        seq.push(\n          assignmentExpression(\n            \"=\",\n            cloneNode(ref2),\n            updateExpression(operator, cloneNode(ref), prefix),\n          ),\n          cloneNode(ref),\n        );\n\n        // (ref = _get(MEMBER), ref2 = ref++, ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(\n          sequenceExpression([this.set(member, value), cloneNode(ref2)]),\n        );\n\n        return;\n      }\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      handleAssignment(this, member, parentPath);\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unnecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(\n        this.optionalCall(member, parentPath.node.arguments),\n      );\n      return;\n    }\n\n    // delete MEMBER -> _delete(MEMBER)\n    if (\n      (process.env.BABEL_8_BREAKING || this.delete) &&\n      parentPath.isUnaryExpression({ operator: \"delete\" })\n    ) {\n      parentPath.replaceWith(this.delete(member));\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\nfunction handleAssignment(\n  state: HandlerState,\n  member: NodePath<t.MemberExpression | t.OptionalMemberExpression>,\n  parentPath: NodePath<t.AssignmentExpression>,\n) {\n  if (state.simpleSet) {\n    member.replaceWith(state.simpleSet(member));\n    return;\n  }\n\n  const { operator, right: value } = parentPath.node;\n\n  if (operator === \"=\") {\n    parentPath.replaceWith(state.set(member, value));\n  } else {\n    const operatorTrunc = operator.slice(0, -1);\n    if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The first access (the get) should do the memo\n      // assignment.\n      state.memoise(member, 1);\n      parentPath.replaceWith(\n        logicalExpression(\n          operatorTrunc as t.LogicalExpression[\"operator\"],\n          state.get(member),\n          state.set(member, value),\n        ),\n      );\n    } else {\n      // Here, the second access (the set) is evaluated first.\n      state.memoise(member, 2);\n      parentPath.replaceWith(\n        state.set(\n          member,\n          binaryExpression(\n            operatorTrunc as t.BinaryExpression[\"operator\"],\n            state.get(member),\n            value,\n          ),\n        ),\n      );\n    }\n  }\n}\n\nexport interface Handler<State> {\n  memoise?(\n    this: HandlerState<State> & State,\n    member: Member,\n    count: number,\n  ): void;\n  destructureSet(\n    this: HandlerState<State> & State,\n    member: Member,\n  ): t.Expression;\n  boundGet(this: HandlerState<State> & State, member: Member): t.Expression;\n  simpleSet?(this: HandlerState<State> & State, member: Member): t.Expression;\n  get(this: HandlerState<State> & State, member: Member): t.Expression;\n  set(\n    this: HandlerState<State> & State,\n    member: Member,\n    value: t.Expression,\n  ): t.Expression;\n  call(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.CallExpression[\"arguments\"],\n  ): t.Expression;\n  optionalCall(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.OptionalCallExpression[\"arguments\"],\n  ): t.Expression;\n  delete(this: HandlerState<State> & State, member: Member): t.Expression;\n}\n\nexport interface HandlerState<State = {}> extends Handler<State> {\n  handle(\n    this: HandlerState<State> & State,\n    member: Member,\n    noDocumentAll?: boolean,\n  ): void;\n  memoiser: AssignmentMemoiser;\n}\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions<CustomState = {}>(\n  path: NodePath,\n  visitor: Visitor<HandlerState<CustomState>>,\n  state: Handler<CustomState> & CustomState,\n) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"],"mappings":"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","ignoreList":[]}