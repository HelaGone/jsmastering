{"version":3,"file":"index.js","names":["_template","require","_t","NOT_LOCAL_BINDING","cloneNode","identifier","isAssignmentExpression","isAssignmentPattern","isFunction","isIdentifier","isLiteral","isNullLiteral","isObjectMethod","isObjectProperty","isRegExpLiteral","isRestElement","isTemplateLiteral","isVariableDeclarator","toBindingIdentifierName","getFunctionArity","node","count","params","findIndex","param","length","buildPropertyMethodAssignmentWrapper","statement","buildGeneratorPropertyMethodAssignmentWrapper","visitor","ReferencedIdentifierBindingIdentifier","path","state","name","localDeclar","scope","getBindingIdentifier","outerDeclar","selfReference","stop","getNameFromLiteralId","id","concat","pattern","flags","quasis","map","quasi","value","raw","join","undefined","wrap","method","hasBinding","hasGlobal","rename","build","generator","template","FUNCTION","FUNCTION_ID","FUNCTION_KEY","generateUidIdentifier","expression","callee","body","i","len","push","getProgramParent","references","visit","selfAssignment","binding","getOwnBinding","kind","traverse","_default","_ref","parent","localBinding","arguments","supportUnicodeId","computed","key","getBinding","constant","operator","left","test","newId"],"sources":["../src/index.ts"],"sourcesContent":["import template from \"@babel/template\";\nimport {\n  NOT_LOCAL_BINDING,\n  cloneNode,\n  identifier,\n  isAssignmentExpression,\n  isAssignmentPattern,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isNullLiteral,\n  isObjectMethod,\n  isObjectProperty,\n  isRegExpLiteral,\n  isRestElement,\n  isTemplateLiteral,\n  isVariableDeclarator,\n  toBindingIdentifierName,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\n\nfunction getFunctionArity(node: t.Function): number {\n  const count = node.params.findIndex(\n    param => isAssignmentPattern(param) || isRestElement(param),\n  );\n  return count === -1 ? node.params.length : count;\n}\n\nconst buildPropertyMethodAssignmentWrapper = template.statement(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\n\nconst buildGeneratorPropertyMethodAssignmentWrapper = template.statement(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\n\ntype State = {\n  name: string;\n  outerDeclar: t.Identifier;\n  selfAssignment: boolean;\n  selfReference: boolean;\n};\n\nconst visitor: Visitor<State> = {\n  \"ReferencedIdentifier|BindingIdentifier\"(\n    path: NodePath<t.Identifier>,\n    state,\n  ) {\n    // check if this node matches our function id\n    if (path.node.name !== state.name) return;\n\n    // check that we don't have a local variable declared as that removes the need\n    // for the wrapper\n    const localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n\n    state.selfReference = true;\n    path.stop();\n  },\n};\n\nfunction getNameFromLiteralId(id: t.Literal) {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (isRegExpLiteral(id)) {\n    return `_${id.pattern}_${id.flags}`;\n  }\n\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n\n  return \"\";\n}\n\nfunction wrap(\n  state: State,\n  method: t.FunctionExpression | t.Class,\n  id: t.Identifier,\n  scope: Scope,\n) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      // we can just munge the local binding\n      scope.rename(id.name);\n    } else {\n      // we don't currently support wrapping class expressions\n      if (!isFunction(method)) return;\n\n      // need to add a wrapper since we can't change the references\n      let build = buildPropertyMethodAssignmentWrapper;\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n\n      const template = (\n        build({\n          FUNCTION: method,\n          FUNCTION_ID: id,\n          FUNCTION_KEY: scope.generateUidIdentifier(id.name),\n        }) as t.ExpressionStatement\n      ).expression as t.CallExpression;\n\n      // shim in dummy params to retain function arity, if you try to read the\n      // source then you'll get the original since it's proxied so it's all good\n      const params = (\n        (template.callee as t.FunctionExpression).body\n          .body[0] as any as t.FunctionExpression\n      ).params;\n\n      for (let i = 0, len = getFunctionArity(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(\n  node: t.FunctionExpression | t.Class,\n  name: string,\n  scope: Scope,\n) {\n  const state: State = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    name: name,\n  };\n\n  // check to see if we have a local binding of the id we're setting inside of\n  // the function, this is important as there are caveats associated\n\n  const binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      // safari will blow up in strict mode with code like:\n      //\n      //   let t = function t(t) {};\n      //\n      // with the error:\n      //\n      //   Cannot declare a parameter named 't' as it shadows the name of a\n      //   strict mode function.\n      //\n      // this isn't to the spec and they've invented this behaviour which is\n      // **extremely** annoying so we avoid setting the name if it has a param\n      // with the same id\n      state.selfReference = true;\n    } else {\n      // otherwise it's defined somewhere in scope like:\n      //\n      //   let t = function () {\n      //     let t = 2;\n      //   };\n      //\n      // so we can safely just set the id and move along as it shadows the\n      // bound function id\n    }\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\n/**\n * Add id to function/class expression inferred from the AST\n *\n * @export\n * @template N The unnamed expression type\n * @param {Object} nodePathLike The NodePath-like input\n * @param {N} nodePathLike.node an AST node\n * @param {NodePath<N>[\"parent\"]} [nodePathLike.parent] The parent of the AST node\n * @param {Scope} nodePathLike.scope The scope associated to the AST node\n * @param {t.LVal | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral} [nodePathLike.id] the fallback naming source when the helper\n * can not infer the function name from the AST\n * @param {boolean} [localBinding=false] whether a name could shadow a self-reference (e.g. converting arrow function)\n * @param {boolean} [supportUnicodeId=false] whether the compilation target supports unicodeId (non-BMP characters) or not\n * @returns {(N | t.CallExpression | void)}\n * - modified node when name can be inferred,\n * - an IIFE when `node` contains a binding shadowing the inferred function name (e.g. `let f = function (f) {}`),\n * - `void` when `node` has `id` property or the helper can not inferred the name or the inferred name contains non-BMP characters that is not supported by current target\n */\nexport default function <N extends t.FunctionExpression | t.Class>(\n  {\n    node,\n    parent,\n    scope,\n    id,\n  }: {\n    node: N;\n    parent?: NodePath<N>[\"parent\"];\n    scope: Scope;\n    id?:\n      | t.AssignmentExpression[\"left\"]\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral;\n  },\n  localBinding = false,\n  supportUnicodeId = false,\n): N | t.CallExpression | void {\n  // has an `id` so we don't need to infer one\n  if (node.id) return;\n\n  if (\n    (isObjectProperty(parent) || isObjectMethod(parent, { kind: \"method\" })) &&\n    (!parent.computed || isLiteral(parent.key))\n  ) {\n    // { foo() {} };\n    id = parent.key as\n      | t.Identifier\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral;\n  } else if (isVariableDeclarator(parent)) {\n    // let foo = function () {};\n    id = parent.id;\n\n    // but not \"let foo = () => {};\" being converted to function expression\n    if (isIdentifier(id) && !localBinding) {\n      const binding = scope.parent.getBinding(id.name);\n      if (\n        binding &&\n        binding.constant &&\n        scope.getBinding(id.name) === binding\n      ) {\n        // always going to reference this method\n        node.id = cloneNode(id);\n        // @ts-expect-error Fixme: avoid mutating AST nodes\n        node.id[NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (isAssignmentExpression(parent, { operator: \"=\" })) {\n    // foo = function () {};\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  let name;\n  if (id && isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && isIdentifier(id)) {\n    name = id.name;\n  }\n\n  if (name === undefined) {\n    return;\n  }\n\n  if (!supportUnicodeId && isFunction(node) && /[\\uD800-\\uDFFF]/.test(name)) {\n    return;\n  }\n\n  name = toBindingIdentifierName(name);\n  const newId = identifier(name);\n\n  // The id shouldn't be considered a local binding to the function because\n  // we are simply trying to set the function name and not actually create\n  // a local binding.\n  // @ts-expect-error Fixme: avoid mutating AST nodes\n  newId[NOT_LOCAL_BINDING] = true;\n\n  const state = visit(node, name, scope);\n  return wrap(state, node, newId, scope) || node;\n}\n"],"mappings":"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","ignoreList":[]}