{"version":3,"file":"index.js","names":["_assert","require","_core","_helperModuleImports","_rewriteThis","_rewriteLiveReferences","_normalizeAndLoadMetadata","Lazy","_dynamicImport","_getModuleName","_core$types","types","booleanLiteral","callExpression","cloneNode","directive","directiveLiteral","expressionStatement","identifier","isIdentifier","memberExpression","stringLiteral","valueToNode","variableDeclaration","variableDeclarator","exports","getDynamicImportSource","rewriteModuleStatementsAndPrepareHeader","path","_ref","exportName","strict","allowTopLevelThis","strictMode","noInterop","_ref$importInterop","importInterop","lazy","_ref$getWrapperPayloa","getWrapperPayload","toGetWrapperPayload","_ref$wrapReference","wrapReference","esNamespaceOnly","filename","_ref$constantReexport","constantReexports","arguments","loose","_ref$enumerableModule","enumerableModuleMeta","noIncompleteNsImportDetection","validateImportInteropOption","isModule","node","sourceType","meta","initializeReexports","hasStrict","directives","some","value","unshiftContainer","headers","hasExports","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","apply","_toConsumableArray","buildExportInitializationStatements","ensureStatementsHoisted","statements","forEach","header","_blockHoist","wrapInterop","programPath","expr","type","hub","addHelper","helper","Error","concat","buildNamespaceInitStatements","metadata","sourceMetadata","length","undefined","_wrapReference","srcNamespaceId","_iterator","_createForOfIteratorHelper","importsNamespace","_step","s","n","done","localName","template","_templateObject","_taggedTemplateLiteral","NAME","SOURCE","err","e","f","srcNamespace","wrap","buildReexportsFromMeta","_iterator2","reexportNamespace","_step2","_templateObject2","_templateObject3","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","_templateObject4","constantComputed","_templateObject5","spec","_templateObject6","_wrapReference2","namespace","stringSpecifiers","Array","from","reexports","_ref2","_ref3","_slicedToArray","importName","NAMESPACE_IMPORT","interop","has","astNodes","EXPORT_NAME","_templateObject7","_templateObject8","_templateObject9","_templateObject10","VERIFY_NAME_LIST","_templateObject11","EXPORTS_LIST","exportedVars","Object","create","_iterator3","local","values","_step3","data","_iterator5","names","_step5","hasReexport","_iterator4","source","_step4","_iterator6","keys","_step6","_iterator7","_step7","scope","generateUidIdentifier","initStatements","_iterator8","_step8","_step8$value","kind","buildInitStatement","_iterator11","_step11","_iterator9","_step9","reexportsStatements","i","_iterator12","_step12","sort","_ref4","_ref5","_ref6","a","_ref7","b","results","_iterator10","_step10","_step10$value","initStatement","chunkSize","uninitializedExportNames","j","_initStatements","buildUndefinedNode","InitTemplate","computed","expression","_templateObject12","_templateObject13","define","_templateObject14","exportNames","initExpr","reduce","acc","params","VALUE"],"sources":["../src/index.ts"],"sourcesContent":["import assert from \"assert\";\nimport { template, types as t } from \"@babel/core\";\n\nimport { isModule } from \"@babel/helper-module-imports\";\n\nimport rewriteThis from \"./rewrite-this.ts\";\nimport rewriteLiveReferences from \"./rewrite-live-references.ts\";\nimport normalizeModuleAndLoadMetadata, {\n  hasExports,\n  isSideEffectImport,\n  validateImportInteropOption,\n} from \"./normalize-and-load-metadata.ts\";\nimport type {\n  ImportInterop,\n  InteropType,\n  ModuleMetadata,\n  SourceModuleMetadata,\n} from \"./normalize-and-load-metadata.ts\";\nimport * as Lazy from \"./lazy-modules.ts\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator,\n} = t;\n\nexport { buildDynamicImport } from \"./dynamic-import.ts\";\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.getDynamicImportSource =\n    // eslint-disable-next-line no-restricted-globals, import/extensions\n    require(\"./dynamic-import\").getDynamicImportSource;\n}\n\nexport { default as getModuleName } from \"./get-module-name.ts\";\nexport type { PluginOptions } from \"./get-module-name.ts\";\n\nexport { hasExports, isSideEffectImport, isModule, rewriteThis };\n\nexport interface RewriteModuleStatementsAndPrepareHeaderOptions {\n  exportName?: string;\n  strict: boolean;\n  allowTopLevelThis?: boolean;\n  strictMode: boolean;\n  loose?: boolean;\n  importInterop?: ImportInterop;\n  noInterop?: boolean;\n  lazy?: Lazy.Lazy;\n  getWrapperPayload?: (\n    source: string,\n    metadata: SourceModuleMetadata,\n    importNodes: t.Node[],\n  ) => unknown;\n  wrapReference?: (ref: t.Expression, payload: unknown) => t.Expression | null;\n  esNamespaceOnly?: boolean;\n  filename: string | undefined;\n  constantReexports?: boolean | void;\n  enumerableModuleMeta?: boolean | void;\n  noIncompleteNsImportDetection?: boolean | void;\n}\n\n/**\n * Perform all of the generic ES6 module rewriting needed to handle initial\n * module processing. This function will rewrite the majority of the given\n * program to reference the modules described by the returned metadata,\n * and returns a list of statements for use when initializing the module.\n */\nexport function rewriteModuleStatementsAndPrepareHeader(\n  path: NodePath<t.Program>,\n  {\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    // TODO(Babel 8): After that `lazy` implementation is moved to the CJS\n    // transform, remove this parameter.\n    lazy,\n    getWrapperPayload = Lazy.toGetWrapperPayload(lazy ?? false),\n    wrapReference = Lazy.wrapReference,\n    esNamespaceOnly,\n    filename,\n\n    constantReexports = process.env.BABEL_8_BREAKING\n      ? undefined\n      : arguments[1].loose,\n    enumerableModuleMeta = process.env.BABEL_8_BREAKING\n      ? undefined\n      : arguments[1].loose,\n    noIncompleteNsImportDetection,\n  }: RewriteModuleStatementsAndPrepareHeaderOptions,\n) {\n  validateImportInteropOption(importInterop);\n  assert(isModule(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n\n  const meta = normalizeModuleAndLoadMetadata(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    getWrapperPayload,\n    esNamespaceOnly,\n    filename,\n  });\n\n  if (!allowTopLevelThis) {\n    rewriteThis(path);\n  }\n\n  rewriteLiveReferences(path, meta, wrapReference);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n    if (!hasStrict) {\n      path.unshiftContainer(\n        \"directives\",\n        directive(directiveLiteral(\"use strict\")),\n      );\n    }\n  }\n\n  const headers = [];\n  if (hasExports(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  // Create all of the statically known named exports.\n  headers.push(\n    ...buildExportInitializationStatements(\n      path,\n      meta,\n      wrapReference,\n      constantReexports,\n      noIncompleteNsImportDetection,\n    ),\n  );\n\n  return { meta, headers };\n}\n\n/**\n * Flag a set of statements as hoisted above all else so that module init\n * statements all run before user code.\n */\nexport function ensureStatementsHoisted(statements: t.Statement[]) {\n  // Force all of the header fields to be at the top of the file.\n  statements.forEach(header => {\n    // @ts-expect-error Fixme: handle _blockHoist property\n    header._blockHoist = 3;\n  });\n}\n\n/**\n * Given an expression for a standard import object, like \"require('foo')\",\n * wrap it in a call to the interop helpers based on the type.\n */\nexport function wrapInterop(\n  programPath: NodePath<t.Program>,\n  expr: t.Expression,\n  type: InteropType,\n): t.CallExpression {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [\n      expr,\n      booleanLiteral(true),\n    ]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\n/**\n * Create the runtime initialization statements for a given requested source.\n * These will initialize all of the runtime import/export logic that\n * can't be handled statically by the statements created by\n * buildExportInitializationStatements().\n */\nexport function buildNamespaceInitStatements(\n  metadata: ModuleMetadata,\n  sourceMetadata: SourceModuleMetadata,\n  constantReexports: boolean | void = false,\n  wrapReference: (\n    ref: t.Identifier,\n    payload: unknown,\n  ) => t.Expression | null = Lazy.wrapReference,\n) {\n  const statements = [];\n\n  const srcNamespaceId = identifier(sourceMetadata.name);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n\n    // Create and assign binding to namespace object\n    statements.push(\n      template.statement`var NAME = SOURCE;`({\n        NAME: localName,\n        SOURCE: cloneNode(srcNamespaceId),\n      }),\n    );\n  }\n\n  const srcNamespace =\n    wrapReference(srcNamespaceId, sourceMetadata.wrap) ?? srcNamespaceId;\n\n  if (constantReexports) {\n    statements.push(\n      ...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference),\n    );\n  }\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    // Assign export to namespace object.\n    statements.push(\n      (!t.isIdentifier(srcNamespace)\n        ? template.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          `\n        : template.statement`EXPORTS.NAME = NAMESPACE;`)({\n        EXPORTS: metadata.exportName,\n        NAME: exportName,\n        NAMESPACE: cloneNode(srcNamespace),\n      }),\n    );\n  }\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(\n      metadata,\n      cloneNode(srcNamespace),\n      constantReexports,\n    );\n    statement.loc = sourceMetadata.reexportAll.loc;\n\n    // Iterate props creating getter for each prop.\n    statements.push(statement);\n  }\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: template.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: template.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `,\n};\n\nfunction buildReexportsFromMeta(\n  meta: ModuleMetadata,\n  metadata: SourceModuleMetadata,\n  constantReexports: boolean,\n  wrapReference: (ref: t.Expression, payload: unknown) => t.Expression | null,\n) {\n  let namespace: t.Expression = identifier(metadata.name);\n  namespace = wrapReference(namespace, metadata.wrap) ?? namespace;\n\n  const { stringSpecifiers } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT: t.Expression = cloneNode(namespace);\n    if (importName === \"default\" && metadata.interop === \"node-default\") {\n      // Nothing, it's ok as-is\n    } else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(\n        NAMESPACE_IMPORT,\n        stringLiteral(importName),\n        true,\n      );\n    } else {\n      NAMESPACE_IMPORT = memberExpression(\n        NAMESPACE_IMPORT,\n        identifier(importName),\n      );\n    }\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT,\n    };\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n}\n\n/**\n * Build an \"__esModule\" header statement setting the property on a given object.\n */\nfunction buildESModuleHeader(\n  metadata: ModuleMetadata,\n  enumerableModuleMeta: boolean | void = false,\n) {\n  return (\n    enumerableModuleMeta\n      ? template.statement`\n        EXPORTS.__esModule = true;\n      `\n      : template.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `\n  )({ EXPORTS: metadata.exportName });\n}\n\n/**\n * Create a re-export initialization loop for a specific imported namespace.\n */\nfunction buildNamespaceReexport(\n  metadata: ModuleMetadata,\n  namespace: t.Expression,\n  constantReexports: boolean | void,\n) {\n  return (\n    constantReexports\n      ? template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      `\n      : // Also skip already assigned bindings if they are strictly equal\n        // to be somewhat more spec-compliant when a file has multiple\n        // namespace re-exports that would cause a binding to be exported\n        // multiple times. However, multiple bindings of the same name that\n        // export the same primitive value are silently skipped\n        // (the spec requires an \"ambiguous bindings\" early error here).\n        template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `\n  )({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName\n      ? template`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({ EXPORTS_LIST: metadata.exportNameListName })\n      : null,\n  });\n}\n\n/**\n * Build a statement declaring a variable that contains all of the exported\n * variable names in an object so they can easily be referenced from an\n * export * from statement to check for conflicts.\n */\nfunction buildExportNameListDeclaration(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n) {\n  const exportedVars = Object.create(null);\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n\n  delete exportedVars.default;\n\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [\n      variableDeclarator(name, valueToNode(exportedVars)),\n    ]),\n  };\n}\n\n/**\n * Create a set of statements that will initialize all of the statically-known\n * export names with their expected values.\n */\nfunction buildExportInitializationStatements(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n  wrapReference: (ref: t.Expression, payload: unknown) => t.Expression | null,\n  constantReexports: boolean | void = false,\n  noIncompleteNsImportDetection: boolean | void = false,\n) {\n  const initStatements: Array<[string, t.Statement | null]> = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {\n      // No-open since these are explicitly set with the \"reexports\" block.\n    } else if (data.kind === \"hoisted\") {\n      initStatements.push([\n        // data.names is always of length 1 because a hoisted export\n        // name must be id of a function declaration\n        data.names[0],\n        buildInitStatement(metadata, data.names, identifier(localName)),\n      ]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(\n        metadata,\n        data,\n        false,\n        wrapReference,\n      );\n      const reexports = [...data.reexports.keys()];\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-module-namespace-exotic-objects\n  // The [Exports] list is ordered as if an Array of those String values\n  // had been sorted using %Array.prototype.sort% using undefined as comparefn\n  initStatements.sort(([a], [b]) => {\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n\n  const results = [];\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    // We generate init statements (`exports.a = exports.b = ... = void 0`)\n    // for every 100 exported names to avoid deeply-nested AST structures.\n    const chunkSize = 100;\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(\n              buildInitStatement(\n                metadata,\n                uninitializedExportNames,\n                programPath.scope.buildUndefinedNode(),\n              ),\n            );\n            // reset after uninitializedExportNames has been transformed\n            // to init statements\n            uninitializedExportNames = [];\n          }\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n      if (uninitializedExportNames.length > 0) {\n        results.push(\n          buildInitStatement(\n            metadata,\n            uninitializedExportNames,\n            programPath.scope.buildUndefinedNode(),\n          ),\n        );\n      }\n    }\n  }\n\n  return results;\n}\n\n/**\n * Given a set of export names, create a set of nested assignments to\n * initialize them all to a given expression.\n */\nconst InitTemplate = {\n  computed: template.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: template.expression`EXPORTS.NAME = VALUE`,\n  define: template.expression`Object.defineProperty(EXPORTS, \"NAME\", { enumerable:true, value: void 0, writable: true })[\"NAME\"] = VALUE`,\n};\n\nfunction buildInitStatement(\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  initExpr: t.Expression,\n) {\n  const { stringSpecifiers, exportName: EXPORTS } = metadata;\n  return expressionStatement(\n    exportNames.reduce((acc, exportName) => {\n      const params = {\n        EXPORTS,\n        NAME: exportName,\n        VALUE: acc,\n      };\n\n      if (exportName === \"__proto__\") {\n        return InitTemplate.define(params);\n      }\n\n      if (stringSpecifiers.has(exportName)) {\n        return InitTemplate.computed(params);\n      }\n\n      return InitTemplate.default(params);\n    }, initExpr),\n  );\n}\n"],"mappings":"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","ignoreList":[]}