{"version":3,"file":"normalize-and-load-metadata.js","names":["_path","require","_helperValidatorIdentifier","_helperSplitExportDeclaration","hasExports","metadata","isSideEffectImport","source","imports","size","importsNamespace","reexports","reexportNamespace","reexportAll","validateImportInteropOption","importInterop","Error","concat","resolveImportInterop","filename","normalizeModuleAndLoadMetadata","programPath","exportName","_ref","_ref$initializeReexpo","initializeReexports","getWrapperPayload","_ref$esNamespaceOnly","esNamespaceOnly","scope","generateUidIdentifier","name","stringSpecifiers","Set","nameAnonymousExports","_getModuleMetadata","getModuleMetadata","local","sources","removeImportExportDeclarations","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","value","_importsNamespace","nameOfnamespace","resolvedInterop","interop","err","e","f","exportNameListName","getExportSpecifierName","path","isIdentifier","node","isStringLiteral","stringValue","isIdentifierName","add","type","assertExportSpecifier","isExportSpecifier","isExportNamespaceSpecifier","buildCodeFrameError","_ref2","localData","getLocalExportMetadata","importNodes","Map","sourceData","getData","sourceNode","data","get","basename","extname","loc","wrap","lazy","referenced","set","push","forEach","child","isImportDeclaration","spec","isImportDefaultSpecifier","localName","reexport","names","isImportNamespaceSpecifier","isImportSpecifier","importName","isExportAllDeclaration","isExportNamedDeclaration","isExportDefaultDeclaration","_iterator2","values","_step2","needsDefault","needsNamed","_iterator4","_step4","_iterator5","_step5","_iterator3","_step3","_step3$value","bindingKindLookup","kind","declaration","isFunctionDeclaration","isClassDeclaration","isVariableDeclaration","Object","keys","getOuterBindingIdentifiers","localMetadata","getLocalMetadata","idPath","undefined","ids","getOuterBindingIdentifierPaths","exported","remove","_blockHoist","replaceWith"],"sources":["../src/normalize-and-load-metadata.ts"],"sourcesContent":["import { basename, extname } from \"path\";\nimport type * as t from \"@babel/types\";\n\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport interface ModuleMetadata {\n  exportName: string;\n  // The name of the variable that will reference an object containing export names.\n  exportNameListName: null | string;\n  hasExports: boolean;\n  // Lookup from local binding to export information.\n  local: Map<string, LocalExportMetadata>;\n  // Lookup of source file to source file metadata.\n  source: Map<string, SourceModuleMetadata>;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n}\n\nexport type InteropType =\n  | \"default\" // Babel interop for default-only imports\n  | \"namespace\" // Babel interop for namespace or default+named imports\n  | \"node-default\" // Node.js interop for default-only imports\n  | \"node-namespace\" // Node.js interop for namespace or default+named imports\n  | \"none\"; // No interop, or named-only imports\n\nexport type ImportInterop =\n  | \"none\"\n  | \"babel\"\n  | \"node\"\n  | ((source: string, filename?: string) => \"none\" | \"babel\" | \"node\");\n\nexport interface SourceModuleMetadata {\n  // A unique variable name to use for this namespace object. Centralized for simplicity.\n  name: string;\n  loc: t.SourceLocation | undefined | null;\n  interop: InteropType;\n  // Local binding to reference from this source namespace. Key: Local name, value: Import name\n  imports: Map<string, string>;\n  // Local names that reference namespace object.\n  importsNamespace: Set<string>;\n  // Reexports to create for namespace. Key: Export name, value: Import name\n  reexports: Map<string, string>;\n  // List of names to re-export namespace as.\n  reexportNamespace: Set<string>;\n  // Tracks if the source should be re-exported.\n  reexportAll: null | {\n    loc: t.SourceLocation | undefined | null;\n  };\n  wrap?: unknown;\n  referenced: boolean;\n}\n\nexport interface LocalExportMetadata {\n  names: Array<string>; // names of exports,\n  kind: \"import\" | \"hoisted\" | \"block\" | \"var\";\n}\n\n/**\n * Check if the module has any exports that need handling.\n */\nexport function hasExports(metadata: ModuleMetadata) {\n  return metadata.hasExports;\n}\n\n/**\n * Check if a given source is an anonymous import, e.g. \"import 'foo';\"\n */\nexport function isSideEffectImport(source: SourceModuleMetadata) {\n  return (\n    source.imports.size === 0 &&\n    source.importsNamespace.size === 0 &&\n    source.reexports.size === 0 &&\n    source.reexportNamespace.size === 0 &&\n    !source.reexportAll\n  );\n}\n\nexport function validateImportInteropOption(\n  importInterop: any,\n): importInterop is ImportInterop {\n  if (\n    typeof importInterop !== \"function\" &&\n    importInterop !== \"none\" &&\n    importInterop !== \"babel\" &&\n    importInterop !== \"node\"\n  ) {\n    throw new Error(\n      `.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`,\n    );\n  }\n  return importInterop;\n}\n\nfunction resolveImportInterop(\n  importInterop: ImportInterop,\n  source: string,\n  filename: string | undefined,\n) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n  return importInterop;\n}\n\n/**\n * Remove all imports and exports from the file, and return all metadata\n * needed to reconstruct the module's behavior.\n */\nexport default function normalizeModuleAndLoadMetadata(\n  programPath: NodePath<t.Program>,\n  exportName: string,\n  {\n    importInterop,\n    initializeReexports = false,\n    getWrapperPayload,\n    esNamespaceOnly = false,\n    filename,\n  }: {\n    importInterop: ImportInterop;\n    initializeReexports: boolean | void;\n    getWrapperPayload?: (\n      source: string,\n      metadata: SourceModuleMetadata,\n      importNodes: t.Node[],\n    ) => unknown;\n    esNamespaceOnly: boolean;\n    filename: string;\n  },\n): ModuleMetadata {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  const stringSpecifiers = new Set<string>();\n\n  nameAnonymousExports(programPath);\n\n  const { local, sources, hasExports } = getModuleMetadata(\n    programPath,\n    { initializeReexports, getWrapperPayload },\n    stringSpecifiers,\n  );\n\n  removeImportExportDeclarations(programPath);\n\n  // Reuse the imported namespace name if there is one.\n  for (const [source, metadata] of sources) {\n    const { importsNamespace, imports } = metadata;\n    // If there is at least one namespace import and other imports, it may collipse with local ident, can be seen in issue 15879.\n    if (importsNamespace.size > 0 && imports.size === 0) {\n      const [nameOfnamespace] = importsNamespace;\n      metadata.name = nameOfnamespace;\n    }\n\n    const resolvedInterop = resolveImportInterop(\n      importInterop,\n      source,\n      filename,\n    );\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      // Both the default and namespace interops pass through __esModule\n      // objects, but the namespace interop is used to enable Babel's\n      // destructuring-like interop behavior for normal CommonJS.\n      // Since some tooling has started to remove that behavior, we expose\n      // it as the `esNamespace` option.\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source: sources,\n    stringSpecifiers,\n  };\n}\n\nfunction getExportSpecifierName(\n  path: NodePath,\n  stringSpecifiers: Set<string>,\n): string {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,\n    );\n  }\n}\n\nfunction assertExportSpecifier(\n  path: NodePath,\n): asserts path is NodePath<t.ExportSpecifier> {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\n      \"Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.\",\n    );\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\n/**\n * Get metadata about the imports and exports present in this module.\n */\nfunction getModuleMetadata(\n  programPath: NodePath<t.Program>,\n  {\n    getWrapperPayload,\n    initializeReexports,\n  }: {\n    getWrapperPayload?: (\n      source: string,\n      metadata: SourceModuleMetadata,\n      importNodes: t.Node[],\n    ) => unknown;\n    initializeReexports: boolean | void;\n  },\n  stringSpecifiers: Set<string>,\n) {\n  const localData = getLocalExportMetadata(\n    programPath,\n    initializeReexports,\n    stringSpecifiers,\n  );\n\n  const importNodes = new Map<string, t.Node[]>();\n  const sourceData = new Map<string, SourceModuleMetadata>();\n  const getData = (sourceNode: t.StringLiteral, node: t.Node) => {\n    const source = sourceNode.value;\n\n    let data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier(\n          basename(source, extname(source)),\n        ).name,\n\n        interop: \"none\",\n\n        loc: null,\n\n        // Data about the requested sources and names.\n        imports: new Map(),\n        importsNamespace: new Set(),\n\n        // Metadata about data that is passed directly from source to export.\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n\n        wrap: null,\n\n        // @ts-expect-error lazy is not listed in the type.\n        // This is needed for compatibility with older version of the commonjs\n        // plusing.\n        // TODO(Babel 8): Remove this\n        get lazy() {\n          return this.wrap === \"lazy\";\n        },\n\n        referenced: false,\n      };\n      sourceData.set(source, data);\n      importNodes.set(source, [node]);\n    } else {\n      importNodes.get(source).push(node);\n    }\n    return data;\n  };\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, \"default\");\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n            data.referenced = true;\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n            data.referenced = true;\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(\n            spec.get(\"imported\"),\n            stringSpecifiers,\n          );\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, importName);\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n            data.referenced = true;\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      data.reexportAll = {\n        loc: child.node.loc,\n      };\n      data.referenced = true;\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(\n          spec.get(\"local\"),\n          stringSpecifiers,\n        );\n        const exportName = getExportSpecifierName(\n          spec.get(\"exported\"),\n          stringSpecifiers,\n        );\n\n        data.reexports.set(exportName, importName);\n        data.referenced = true;\n\n        if (exportName === \"__esModule\") {\n          throw spec\n            .get(\"exported\")\n            .buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (\n      child.isExportNamedDeclaration() ||\n      child.isExportDefaultDeclaration()\n    ) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      // TODO(logan): Using the namespace interop here is unfortunate. Revisit.\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  if (getWrapperPayload) {\n    for (const [source, metadata] of sourceData) {\n      metadata.wrap = getWrapperPayload(\n        source,\n        metadata,\n        importNodes.get(source),\n      );\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    sources: sourceData,\n  };\n}\n\ntype ModuleBindingKind = \"import\" | \"hoisted\" | \"block\" | \"var\";\n/**\n * Get metadata about local variables that are exported.\n */\nfunction getLocalExportMetadata(\n  programPath: NodePath<t.Program>,\n  initializeReexports: boolean | void,\n  stringSpecifiers: Set<string>,\n): Map<string, LocalExportMetadata> {\n  const bindingKindLookup = new Map();\n\n  programPath.get(\"body\").forEach((child: NodePath) => {\n    let kind: ModuleBindingKind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (\n          initializeReexports &&\n          child.node.source &&\n          child.get(\"source\").isStringLiteral()\n        ) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({ kind: \"var\" })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n\n  const localMetadata = new Map();\n  const getLocalMetadata = (idPath: NodePath<t.Identifier>) => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(\n          `Exporting local \"${localName}\", which is not declared.`,\n        );\n      }\n\n      metadata = {\n        names: [],\n        kind,\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (\n      child.isExportNamedDeclaration() &&\n      (initializeReexports || !child.node.source)\n    ) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError(\n              'Illegal export \"__esModule\".',\n            );\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): improve babel-types\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    }\n  });\n  return localMetadata;\n}\n\n/**\n * Ensure that all exported values have local binding names.\n */\nfunction nameAnonymousExports(programPath: NodePath<t.Program>) {\n  // Name anonymous exported locals.\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    splitExportDeclaration(child);\n  });\n}\n\nfunction removeImportExportDeclarations(programPath: NodePath<t.Program>) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      // export default foo;\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(\n          declaration as NodePath<t.FunctionDeclaration | t.ClassDeclaration>,\n        );\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}\n"],"mappings":"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","ignoreList":[]}