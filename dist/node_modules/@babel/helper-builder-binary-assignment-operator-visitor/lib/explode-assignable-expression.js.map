{"version":3,"file":"explode-assignable-expression.js","names":["_t","require","assignmentExpression","cloneNode","isIdentifier","isLiteral","isMemberExpression","isPrivateName","isPureish","isSuper","memberExpression","toComputedKey","getObjRef","node","nodes","scope","ref","hasBinding","name","object","Error","concat","temp","generateUidIdentifierBasedOnNode","push","id","getPropRef","prop","property","key","explode","obj","uid","computed"],"sources":["../src/explode-assignable-expression.ts"],"sourcesContent":["import type { Scope } from \"@babel/traverse\";\nimport {\n  assignmentExpression,\n  cloneNode,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isPrivateName,\n  isPureish,\n  isSuper,\n  memberExpression,\n  toComputedKey,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nfunction getObjRef(\n  node: t.Identifier | t.MemberExpression,\n  nodes: Array<t.AssignmentExpression>,\n  scope: Scope,\n): t.Identifier | t.Super {\n  let ref;\n  if (isIdentifier(node)) {\n    if (scope.hasBinding(node.name)) {\n      // this variable is declared in scope so we can be 100% sure\n      // that evaluating it multiple times won't trigger a getter\n      // or something else\n      return node;\n    } else {\n      // could possibly trigger a getter so we need to only evaluate\n      // it once\n      ref = node;\n    }\n  } else if (isMemberExpression(node)) {\n    ref = node.object;\n\n    if (isSuper(ref) || (isIdentifier(ref) && scope.hasBinding(ref.name))) {\n      // the object reference that we need to save is locally declared\n      // so as per the previous comment we can be 100% sure evaluating\n      // it multiple times will be safe\n      // Super cannot be directly assigned so lets return it also\n      return ref;\n    }\n  } else {\n    throw new Error(`We can't explode this node type ${node[\"type\"]}`);\n  }\n\n  const temp = scope.generateUidIdentifierBasedOnNode(ref);\n  scope.push({ id: temp });\n  nodes.push(assignmentExpression(\"=\", cloneNode(temp), cloneNode(ref)));\n  return temp;\n}\n\nfunction getPropRef(\n  node: t.MemberExpression,\n  nodes: Array<t.AssignmentExpression>,\n  scope: Scope,\n): t.Identifier | t.Literal {\n  const prop = node.property;\n  if (isPrivateName(prop)) {\n    throw new Error(\n      \"We can't generate property ref for private name, please install `@babel/plugin-transform-class-properties`\",\n    );\n  }\n  const key = toComputedKey(node, prop);\n  if (isLiteral(key) && isPureish(key)) return key;\n\n  const temp = scope.generateUidIdentifierBasedOnNode(prop);\n  scope.push({ id: temp });\n  nodes.push(assignmentExpression(\"=\", cloneNode(temp), cloneNode(prop)));\n  return temp;\n}\n\nexport default function explode(\n  node: t.Identifier | t.MemberExpression,\n  nodes: Array<t.AssignmentExpression>,\n  scope: Scope,\n): {\n  uid: t.Identifier | t.MemberExpression | t.Super;\n  ref: t.Identifier | t.MemberExpression;\n} {\n  const obj = getObjRef(node, nodes, scope);\n\n  let ref, uid;\n\n  if (isIdentifier(node)) {\n    ref = cloneNode(node);\n    uid = obj;\n  } else {\n    const prop = getPropRef(node, nodes, scope);\n    const computed = node.computed || isLiteral(prop);\n    uid = memberExpression(cloneNode(obj), cloneNode(prop), computed);\n    ref = memberExpression(cloneNode(obj), cloneNode(prop), computed);\n  }\n\n  return {\n    uid: uid,\n    ref: ref,\n  };\n}\n"],"mappings":"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","ignoreList":[]}