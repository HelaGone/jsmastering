{"version":3,"file":"index.js","names":["_helperEnvironmentVisitor","require","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_core","_core$types","types","assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","ns","exports","environmentVisitor","skipAllButComputedKey","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","visitor","traverse","visitors","merge","Super","path","state","node","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","_ref","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","computed","property","memo","maybeGenerateMemoised","memoiser","set","prop","_superMember$node","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","needAccessFirst","isDerivedConstructor","value","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optionalCall","_delete","template","expression","ast","_templateObject","_taggedTemplateLiteral","_templateObject2","looseHandlers","Object","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","opts","_classCallCheck","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","_createClass","key","replace","refToPreserve","handler","shouldSkip","parentKey","bind","boundGet"],"sources":["../src/index.ts"],"sourcesContent":["import type { File } from \"@babel/core\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport { traverse, template, types as t } from \"@babel/core\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nconst {\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} = t;\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  const ns = require(\"@babel/helper-environment-visitor\");\n  // eslint-disable-next-line no-restricted-globals\n  exports.environmentVisitor = ns.default;\n  // eslint-disable-next-line no-restricted-globals\n  exports.skipAllButComputedKey = ns.skipAllButComputedKey;\n}\n\ntype ThisRef = {\n  needAccessFirst?: boolean;\n  this: t.ThisExpression;\n};\n\n/**\n * Creates an expression which result is the proto of objectRef.\n *\n * @example <caption>isStatic === true</caption>\n *\n *   helpers.getPrototypeOf(CLASS)\n *\n * @example <caption>isStatic === false</caption>\n *\n *   helpers.getPrototypeOf(CLASS.prototype)\n */\nfunction getPrototypeOfExpression(\n  objectRef: t.Identifier,\n  isStatic: boolean,\n  file: File,\n  isPrivateMethod: boolean,\n) {\n  objectRef = cloneNode(objectRef);\n  const targetRef =\n    isStatic || isPrivateMethod\n      ? objectRef\n      : memberExpression(objectRef, identifier(\"prototype\"));\n\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nconst visitor = traverse.visitors.merge<\n  HandlerState<ReplaceState> & ReplaceState\n>([\n  environmentVisitor,\n  {\n    Super(path, state) {\n      const { node, parentPath } = path;\n      if (!parentPath.isMemberExpression({ object: node })) return;\n      state.handle(parentPath);\n    },\n  },\n]);\n\nconst unshadowSuperBindingVisitor = traverse.visitors.merge<{\n  refName: string;\n}>([\n  environmentVisitor,\n  {\n    Scopable(path, { refName }) {\n      // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n      const binding = path.scope.getOwnBinding(refName);\n      if (binding && binding.identifier.name === refName) {\n        path.scope.rename(refName);\n      }\n    },\n  },\n]);\n\ntype SharedState = {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: () => t.Identifier;\n  getSuperRef: () => t.Identifier;\n  // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n  boundGet: HandlerState[\"get\"];\n};\n\ntype Handler = HandlerState<SharedState> & SharedState;\ntype SuperMember = NodePath<\n  t.MemberExpression & {\n    object: t.Super;\n    property: Exclude<t.MemberExpression[\"property\"], t.PrivateName>;\n  }\n>;\n\ninterface SpecHandler\n  extends Pick<\n    Handler,\n    | \"memoise\"\n    | \"get\"\n    | \"set\"\n    | \"destructureSet\"\n    | \"call\"\n    | \"optionalCall\"\n    | \"delete\"\n  > {\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ): t.CallExpression;\n  _getThisRefs(): ThisRef;\n  prop(this: Handler & SpecHandler, superMember: SuperMember): t.Expression;\n}\n\nconst specHandlers: SpecHandler = {\n  memoise(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    count: number,\n  ) {\n    const { scope, node } = superMember;\n    const { computed, property } = node;\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(this: Handler & SpecHandler, superMember: SuperMember) {\n    const { computed, property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral((property as t.Identifier).name);\n  },\n\n  get(this: Handler & SpecHandler, superMember: SuperMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ) {\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"get\"), [\n      thisRefs.needAccessFirst\n        ? sequenceExpression([thisRefs.this, proto])\n        : proto,\n      this.prop(superMember),\n      thisRefs.this,\n    ]);\n  },\n\n  _getThisRefs(this: Handler & SpecHandler): ThisRef {\n    return {\n      needAccessFirst: this.isDerivedConstructor,\n      this: thisExpression(),\n    };\n  },\n\n  set(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const thisRefs = this._getThisRefs();\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"set\"), [\n      thisRefs.needAccessFirst\n        ? sequenceExpression([thisRefs.this, proto])\n        : proto,\n      this.prop(superMember),\n      value,\n      thisRefs.this,\n      booleanLiteral(superMember.isInStrictMode()),\n    ]);\n  },\n\n  destructureSet(this: Handler & SpecHandler, superMember: SuperMember) {\n    throw superMember.buildCodeFrameError(\n      `Destructuring to a super field is not supported yet.`,\n    );\n  },\n\n  call(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      false,\n    );\n  },\n\n  optionalCall(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      true,\n    );\n  },\n\n  delete(this: Handler & SpecHandler, superMember: SuperMember) {\n    if (superMember.node.computed) {\n      return sequenceExpression([\n        callExpression(this.file.addHelper(\"toPropertyKey\"), [\n          cloneNode(superMember.node.property),\n        ]),\n        template.expression.ast`\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        `,\n      ]);\n    } else {\n      return template.expression.ast`\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      `;\n    }\n  },\n};\n\nconst looseHandlers = {\n  ...specHandlers,\n\n  prop(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { isStatic, getSuperRef } = this;\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    let object;\n    if (isStatic) {\n      object =\n        getSuperRef() ??\n        memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      object = memberExpression(\n        getSuperRef() ?? identifier(\"Object\"),\n        identifier(\"prototype\"),\n      );\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return assignmentExpression(\n      \"=\",\n      memberExpression(thisExpression(), prop, computed),\n      value,\n    );\n  },\n\n  destructureSet(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return memberExpression(thisExpression(), prop, computed);\n  },\n\n  call(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, true);\n  },\n};\n\ntype ReplaceSupersOptionsBase = {\n  methodPath: NodePath<\n    | t.ClassMethod\n    | t.ClassProperty\n    | t.ObjectMethod\n    | t.ClassPrivateMethod\n    | t.ClassPrivateProperty\n    | t.StaticBlock\n  >;\n  constantSuper?: boolean;\n  file: File;\n  // objectRef might have been shadowed in child scopes,\n  // in that case, we need to rename related variables.\n  refToPreserve?: t.Identifier;\n};\n\ntype ReplaceSupersOptions = ReplaceSupersOptionsBase &\n  (\n    | { objectRef?: undefined; getObjectRef: () => t.Node }\n    | { objectRef: t.Node; getObjectRef?: undefined }\n  ) &\n  (\n    | { superRef?: undefined; getSuperRef: () => t.Node }\n    | { superRef: t.Node; getSuperRef?: undefined }\n  );\n\ninterface ReplaceState {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: ReplaceSupers[\"getObjectRef\"];\n  getSuperRef: ReplaceSupers[\"getSuperRef\"];\n}\n\nexport default class ReplaceSupers {\n  constructor(opts: ReplaceSupersOptions) {\n    const path = opts.methodPath;\n\n    this.methodPath = path;\n    this.isDerivedConstructor =\n      path.isClassMethod({ kind: \"constructor\" }) && !!opts.superRef;\n    this.isStatic =\n      path.isObjectMethod() ||\n      // @ts-expect-error static is not in ClassPrivateMethod\n      path.node.static ||\n      path.isStaticBlock?.();\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n\n    this.file = opts.file;\n    this.constantSuper = process.env.BABEL_8_BREAKING\n      ? opts.constantSuper\n      : // Fallback to isLoose for backward compatibility\n        opts.constantSuper ?? (opts as any).isLoose;\n    this.opts = opts;\n  }\n\n  declare file: File;\n  declare isDerivedConstructor: boolean;\n  declare constantSuper: boolean;\n  declare isPrivateMethod: boolean;\n  declare isStatic: boolean;\n  declare methodPath: NodePath;\n  declare opts: ReplaceSupersOptions;\n\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) {\n      return cloneNode(this.opts.getSuperRef());\n    }\n  }\n\n  replace() {\n    const { methodPath } = this;\n    // https://github.com/babel/babel/issues/11994\n    if (this.opts.refToPreserve) {\n      methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name,\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n\n    // todo: this should have been handled by the environmentVisitor,\n    // consider add visitSelf support for the path.traverse\n    // @ts-expect-error: Refine typings in packages/babel-traverse/src/types.ts\n    // shouldSkip is accepted in traverseNode\n    visitor.shouldSkip = (path: NodePath) => {\n      if (path.parentPath === methodPath) {\n        if (path.parentKey === \"decorators\" || path.parentKey === \"key\") {\n          return true;\n        }\n      }\n    };\n\n    memberExpressionToFunctions<ReplaceState>(methodPath, visitor, {\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n      boundGet: handler.get,\n      ...handler,\n    });\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;AACA,IAAAA,yBAAA,GAAAC,OAAA;AACA,IAAAC,kCAAA,GAAAD,OAAA;AAEA,IAAAE,6BAAA,GAAAF,OAAA;AACA,IAAAG,KAAA,GAAAH,OAAA;AAEA,IAAAI,WAAA,GAUID,KAAA,CAAAE,KAAC;EATHC,oBAAoB,GAAAF,WAAA,CAApBE,oBAAoB;EACpBC,cAAc,GAAAH,WAAA,CAAdG,cAAc;EACdC,cAAc,GAAAJ,WAAA,CAAdI,cAAc;EACdC,SAAS,GAAAL,WAAA,CAATK,SAAS;EACTC,UAAU,GAAAN,WAAA,CAAVM,UAAU;EACVC,gBAAgB,GAAAP,WAAA,CAAhBO,gBAAgB;EAChBC,kBAAkB,GAAAR,WAAA,CAAlBQ,kBAAkB;EAClBC,aAAa,GAAAT,WAAA,CAAbS,aAAa;EACbC,cAAA,GAAAV,WAAA,CAAAU,cAAA;AAG+D;EAE/D,IAAMC,EAAE,GAAGf,OAAO,CAAC,mCAAmC,CAAC;EAEvDgB,OAAO,CAACC,kBAAkB,GAAGF,EAAE,WAAQ;EAEvCC,OAAO,CAACE,qBAAqB,GAAGH,EAAE,CAACG,qBAAqB;AAC1D;AAkBA,SAASC,wBAAwBA,CAC/BC,SAAuB,EACvBC,QAAiB,EACjBC,IAAU,EACVC,eAAwB,EACxB;EACAH,SAAS,GAAGX,SAAS,CAACW,SAAS,CAAC;EAChC,IAAMI,SAAS,GACbH,QAAQ,IAAIE,eAAe,GACvBH,SAAS,GACTT,gBAAgB,CAACS,SAAS,EAAEV,UAAU,CAAC,WAAW,CAAC,CAAC;EAE1D,OAAOF,cAAc,CAACc,IAAI,CAACG,SAAS,CAAC,gBAAgB,CAAC,EAAE,CAACD,SAAS,CAAC,CAAC;AACtE;AAEA,IAAME,OAAO,GAAGvB,KAAA,CAAAwB,QAAQ,CAACC,QAAQ,CAACC,KAAK,CAErC,CACA9B,yBAAA,WAAkB,EAClB;EACE+B,KAAK,WAAAA,MAACC,IAAI,EAAEC,KAAK,EAAE;IACjB,IAAQC,IAAI,GAAiBF,IAAI,CAAzBE,IAAI;MAAEC,UAAA,GAAeH,IAAI,CAAnBG,UAAA;IACd,IAAI,CAACA,UAAU,CAACC,kBAAkB,CAAC;MAAEC,MAAM,EAAEH;IAAK,CAAC,CAAC,EAAE;IACtDD,KAAK,CAACK,MAAM,CAACH,UAAU,CAAC;EAC1B;AACF,CAAC,CACF,CAAC;AAEF,IAAMI,2BAA2B,GAAGnC,KAAA,CAAAwB,QAAQ,CAACC,QAAQ,CAACC,KAAK,CAExD,CACD9B,yBAAA,WAAkB,EAClB;EACEwC,QAAQ,WAAAA,SAACR,IAAI,EAAAS,IAAA,EAAe;IAAA,IAAXC,OAAA,GAAAD,IAAA,CAAAC,OAAA;IAEf,IAAMC,OAAO,GAAGX,IAAI,CAACY,KAAK,CAACC,aAAa,CAACH,OAAO,CAAC;IACjD,IAAIC,OAAO,IAAIA,OAAO,CAAChC,UAAU,CAACmC,IAAI,KAAKJ,OAAO,EAAE;MAClDV,IAAI,CAACY,KAAK,CAACG,MAAM,CAACL,OAAO,CAAC;IAC5B;EACF;AACF,CAAC,CACF,CAAC;AA0CF,IAAMM,YAAyB,GAAG;EAChCC,OAAO,WAAAA,QAELC,WAAwB,EACxBC,KAAa,EACb;IACA,IAAQP,KAAK,GAAWM,WAAW,CAA3BN,KAAK;MAAEV,IAAA,GAASgB,WAAW,CAApBhB,IAAA;IACf,IAAQkB,QAAQ,GAAelB,IAAI,CAA3BkB,QAAQ;MAAEC,QAAA,GAAanB,IAAI,CAAjBmB,QAAA;IAClB,IAAI,CAACD,QAAQ,EAAE;MACb;IACF;IAEA,IAAME,IAAI,GAAGV,KAAK,CAACW,qBAAqB,CAACF,QAAQ,CAAC;IAClD,IAAI,CAACC,IAAI,EAAE;MACT;IACF;IAEA,IAAI,CAACE,QAAQ,CAACC,GAAG,CAACJ,QAAQ,EAAEC,IAAI,EAAEH,KAAK,CAAC;EAC1C,CAAC;EAEDO,IAAI,WAAAA,KAA8BR,WAAwB,EAAE;IAC1D,IAAAS,iBAAA,GAA+BT,WAAW,CAAChB,IAAI;MAAvCkB,QAAQ,GAAAO,iBAAA,CAARP,QAAQ;MAAEC,QAAA,GAAAM,iBAAA,CAAAN,QAAA;IAClB,IAAI,IAAI,CAACG,QAAQ,CAACI,GAAG,CAACP,QAAQ,CAAC,EAAE;MAC/B,OAAO3C,SAAS,CAAC,IAAI,CAAC8C,QAAQ,CAACK,GAAG,CAACR,QAAQ,CAAC,CAAC;IAC/C;IAEA,IAAID,QAAQ,EAAE;MACZ,OAAO1C,SAAS,CAAC2C,QAAQ,CAAC;IAC5B;IAEA,OAAOvC,aAAa,CAAEuC,QAAQ,CAAkBP,IAAI,CAAC;EACvD,CAAC;EAEDe,GAAG,WAAAA,IAA8BX,WAAwB,EAAE;IACzD,OAAO,IAAI,CAACY,IAAI,CAACZ,WAAW,EAAE,IAAI,CAACa,YAAY,CAAC,CAAC,CAAC;EACpD,CAAC;EAEDD,IAAI,WAAAA,KAEFZ,WAAwB,EACxBc,QAAiB,EACjB;IACA,IAAMC,KAAK,GAAG7C,wBAAwB,CACpC,IAAI,CAAC8C,YAAY,CAAC,CAAC,EACnB,IAAI,CAAC5C,QAAQ,EACb,IAAI,CAACC,IAAI,EACT,IAAI,CAACC,eACP,CAAC;IACD,OAAOf,cAAc,CAAC,IAAI,CAACc,IAAI,CAACG,SAAS,CAAC,KAAK,CAAC,EAAE,CAChDsC,QAAQ,CAACG,eAAe,GACpBtD,kBAAkB,CAAC,CAACmD,QAAQ,QAAK,EAAEC,KAAK,CAAC,CAAC,GAC1CA,KAAK,EACT,IAAI,CAACP,IAAI,CAACR,WAAW,CAAC,EACtBc,QAAQ,QAAK,CACd,CAAC;EACJ,CAAC;EAEDD,YAAY,WAAAA,aAAA,EAAuC;IACjD,OAAO;MACLI,eAAe,EAAE,IAAI,CAACC,oBAAoB;MAC1C,QAAMrD,cAAc,CAAC;IACvB,CAAC;EACH,CAAC;EAED0C,GAAG,WAAAA,IAEDP,WAAwB,EACxBmB,KAAmB,EACnB;IACA,IAAML,QAAQ,GAAG,IAAI,CAACD,YAAY,CAAC,CAAC;IACpC,IAAME,KAAK,GAAG7C,wBAAwB,CACpC,IAAI,CAAC8C,YAAY,CAAC,CAAC,EACnB,IAAI,CAAC5C,QAAQ,EACb,IAAI,CAACC,IAAI,EACT,IAAI,CAACC,eACP,CAAC;IACD,OAAOf,cAAc,CAAC,IAAI,CAACc,IAAI,CAACG,SAAS,CAAC,KAAK,CAAC,EAAE,CAChDsC,QAAQ,CAACG,eAAe,GACpBtD,kBAAkB,CAAC,CAACmD,QAAQ,QAAK,EAAEC,KAAK,CAAC,CAAC,GAC1CA,KAAK,EACT,IAAI,CAACP,IAAI,CAACR,WAAW,CAAC,EACtBmB,KAAK,EACLL,QAAQ,QAAK,EACbxD,cAAc,CAAC0C,WAAW,CAACoB,cAAc,CAAC,CAAC,CAAC,CAC7C,CAAC;EACJ,CAAC;EAEDC,cAAc,WAAAA,eAA8BrB,WAAwB,EAAE;IACpE,MAAMA,WAAW,CAACsB,mBAAmB,uDAErC,CAAC;EACH,CAAC;EAEDC,IAAI,WAAAA,KAEFvB,WAAwB,EACxBwB,IAAmC,EACnC;IACA,IAAMV,QAAQ,GAAG,IAAI,CAACD,YAAY,CAAC,CAAC;IACpC,OAAO,IAAA5D,6BAAA,WAAY,EACjB,IAAI,CAAC2D,IAAI,CAACZ,WAAW,EAAEc,QAAQ,CAAC,EAChCtD,SAAS,CAACsD,QAAQ,QAAK,CAAC,EACxBU,IAAI,EACJ,KACF,CAAC;EACH,CAAC;EAEDC,YAAY,WAAAA,aAEVzB,WAAwB,EACxBwB,IAAmC,EACnC;IACA,IAAMV,QAAQ,GAAG,IAAI,CAACD,YAAY,CAAC,CAAC;IACpC,OAAO,IAAA5D,6BAAA,WAAY,EACjB,IAAI,CAAC2D,IAAI,CAACZ,WAAW,EAAEc,QAAQ,CAAC,EAChCtD,SAAS,CAACsD,QAAQ,QAAK,CAAC,EACxBU,IAAI,EACJ,IACF,CAAC;EACH,CAAC;EAAA,mBAAAE,QAEmC1B,WAAwB,EAAE;IAC5D,IAAIA,WAAW,CAAChB,IAAI,CAACkB,QAAQ,EAAE;MAC7B,OAAOvC,kBAAkB,CAAC,CACxBJ,cAAc,CAAC,IAAI,CAACc,IAAI,CAACG,SAAS,CAAC,eAAe,CAAC,EAAE,CACnDhB,SAAS,CAACwC,WAAW,CAAChB,IAAI,CAACmB,QAAQ,CAAC,CACrC,CAAC,EACFjD,KAAA,CAAAyE,QAAQ,CAACC,UAAU,CAACC,GAAI,CAAAC,eAAA,KAAAA,eAAA,GAAAC,sBAAA,+GAGzB,CAAC;IACJ,CAAC,MAAM;MACL,OAAO7E,KAAA,CAAAyE,QAAQ,CAACC,UAAU,CAACC,GAAI,CAAAG,gBAAA,KAAAA,gBAAA,GAAAD,sBAAA;IAGjC;EACF;AACF,CAAC;AAED,IAAME,aAAa,GAAAC,MAAA,CAAAC,MAAA,KACdrC,YAAY;EAEfU,IAAI,WAAAA,KAAsCR,WAAwB,EAAE;IAClE,IAAQG,QAAA,GAAaH,WAAW,CAAChB,IAAI,CAA7BmB,QAAA;IACR,IAAI,IAAI,CAACG,QAAQ,CAACI,GAAG,CAACP,QAAQ,CAAC,EAAE;MAC/B,OAAO3C,SAAS,CAAC,IAAI,CAAC8C,QAAQ,CAACK,GAAG,CAACR,QAAQ,CAAC,CAAC;IAC/C;IAEA,OAAO3C,SAAS,CAAC2C,QAAQ,CAAC;EAC5B,CAAC;EAEDQ,GAAG,WAAAA,IAAsCX,WAAwB,EAAE;IACjE,IAAQ5B,QAAQ,GAAkB,IAAI,CAA9BA,QAAQ;MAAEgE,WAAA,GAAgB,IAAI,CAApBA,WAAA;IAClB,IAAQlC,QAAA,GAAaF,WAAW,CAAChB,IAAI,CAA7BkB,QAAA;IACR,IAAMM,IAAI,GAAG,IAAI,CAACA,IAAI,CAACR,WAAW,CAAC;IAEnC,IAAIb,MAAM;IACV,IAAIf,QAAQ,EAAE;MAAA,IAAAiE,YAAA;MACZlD,MAAM,IAAAkD,YAAA,GACJD,WAAW,CAAC,CAAC,YAAAC,YAAA,GACb3E,gBAAgB,CAACD,UAAU,CAAC,UAAU,CAAC,EAAEA,UAAU,CAAC,WAAW,CAAC,CAAC;IACrE,CAAC,MAAM;MAAA,IAAA6E,aAAA;MACLnD,MAAM,GAAGzB,gBAAgB,EAAA4E,aAAA,GACvBF,WAAW,CAAC,CAAC,YAAAE,aAAA,GAAI7E,UAAU,CAAC,QAAQ,CAAC,EACrCA,UAAU,CAAC,WAAW,CACxB,CAAC;IACH;IAEA,OAAOC,gBAAgB,CAACyB,MAAM,EAAEqB,IAAI,EAAEN,QAAQ,CAAC;EACjD,CAAC;EAEDK,GAAG,WAAAA,IAEDP,WAAwB,EACxBmB,KAAmB,EACnB;IACA,IAAQjB,QAAA,GAAaF,WAAW,CAAChB,IAAI,CAA7BkB,QAAA;IACR,IAAMM,IAAI,GAAG,IAAI,CAACA,IAAI,CAACR,WAAW,CAAC;IAEnC,OAAO3C,oBAAoB,CACzB,GAAG,EACHK,gBAAgB,CAACG,cAAc,CAAC,CAAC,EAAE2C,IAAI,EAAEN,QAAQ,CAAC,EAClDiB,KACF,CAAC;EACH,CAAC;EAEDE,cAAc,WAAAA,eAEZrB,WAAwB,EACxB;IACA,IAAQE,QAAA,GAAaF,WAAW,CAAChB,IAAI,CAA7BkB,QAAA;IACR,IAAMM,IAAI,GAAG,IAAI,CAACA,IAAI,CAACR,WAAW,CAAC;IAEnC,OAAOtC,gBAAgB,CAACG,cAAc,CAAC,CAAC,EAAE2C,IAAI,EAAEN,QAAQ,CAAC;EAC3D,CAAC;EAEDqB,IAAI,WAAAA,KAEFvB,WAAwB,EACxBwB,IAAmC,EACnC;IACA,OAAO,IAAAvE,6BAAA,WAAY,EAAC,IAAI,CAAC0D,GAAG,CAACX,WAAW,CAAC,EAAEnC,cAAc,CAAC,CAAC,EAAE2D,IAAI,EAAE,KAAK,CAAC;EAC3E,CAAC;EAEDC,YAAY,WAAAA,aAEVzB,WAAwB,EACxBwB,IAAmC,EACnC;IACA,OAAO,IAAAvE,6BAAA,WAAY,EAAC,IAAI,CAAC0D,GAAG,CAACX,WAAW,CAAC,EAAEnC,cAAc,CAAC,CAAC,EAAE2D,IAAI,EAAE,IAAI,CAAC;EAC1E;AAAC,EACF;AAAA,IAsCoBe,aAAa;EAChC,SAAAA,cAAYC,IAA0B,EAAE;IAAAC,eAAA,OAAAF,aAAA;IAAA,IAAAG,mBAAA;IACtC,IAAM5D,IAAI,GAAG0D,IAAI,CAACG,UAAU;IAE5B,IAAI,CAACA,UAAU,GAAG7D,IAAI;IACtB,IAAI,CAACoC,oBAAoB,GACvBpC,IAAI,CAAC8D,aAAa,CAAC;MAAEC,IAAI,EAAE;IAAc,CAAC,CAAC,IAAI,CAAC,CAACL,IAAI,CAACM,QAAQ;IAChE,IAAI,CAAC1E,QAAQ,GACXU,IAAI,CAACiE,cAAc,CAAC,CAAC,IAErBjE,IAAI,CAACE,IAAI,UAAO,KAChBF,IAAI,CAACkE,aAAa,oBAAlBlE,IAAI,CAACkE,aAAa,CAAG,CAAC;IACxB,IAAI,CAAC1E,eAAe,GAAGQ,IAAI,CAACmE,SAAS,CAAC,CAAC,IAAInE,IAAI,CAACoE,QAAQ,CAAC,CAAC;IAE1D,IAAI,CAAC7E,IAAI,GAAGmE,IAAI,CAACnE,IAAI;IACrB,IAAI,CAAC8E,aAAa,IAAAT,mBAAA,GAGdF,IAAI,CAACW,aAAa,YAAAT,mBAAA,GAAKF,IAAI,CAASY,OAAO;IAC/C,IAAI,CAACZ,IAAI,GAAGA,IAAI;EAClB;EAAA,OAAAa,YAAA,CAAAd,aAAA;IAAAe,GAAA;IAAAnC,KAAA,EAUA,SAAAH,aAAA,EAAe;MACb,OAAOxD,SAAS,CAAC,IAAI,CAACgF,IAAI,CAACrE,SAAS,IAAI,IAAI,CAACqE,IAAI,CAACxB,YAAY,CAAC,CAAC,CAAC;IACnE;EAAA;IAAAsC,GAAA;IAAAnC,KAAA,EAEA,SAAAiB,YAAA,EAAc;MACZ,IAAI,IAAI,CAACI,IAAI,CAACM,QAAQ,EAAE,OAAOtF,SAAS,CAAC,IAAI,CAACgF,IAAI,CAACM,QAAQ,CAAC;MAC5D,IAAI,IAAI,CAACN,IAAI,CAACJ,WAAW,EAAE;QACzB,OAAO5E,SAAS,CAAC,IAAI,CAACgF,IAAI,CAACJ,WAAW,CAAC,CAAC,CAAC;MAC3C;IACF;EAAA;IAAAkB,GAAA;IAAAnC,KAAA,EAEA,SAAAoC,QAAA,EAAU;MACR,IAAQZ,UAAA,GAAe,IAAI,CAAnBA,UAAA;MAER,IAAI,IAAI,CAACH,IAAI,CAACgB,aAAa,EAAE;QAC3Bb,UAAU,CAACjE,QAAQ,CAACW,2BAA2B,EAAE;UAC/CG,OAAO,EAAE,IAAI,CAACgD,IAAI,CAACgB,aAAa,CAAC5D;QACnC,CAAC,CAAC;MACJ;MAEA,IAAM6D,OAAO,GAAG,IAAI,CAACN,aAAa,GAAGlB,aAAa,GAAGnC,YAAY;MAMjErB,OAAO,CAACiF,UAAU,GAAI,UAAA5E,IAAc,EAAK;QACvC,IAAIA,IAAI,CAACG,UAAU,KAAK0D,UAAU,EAAE;UAClC,IAAI7D,IAAI,CAAC6E,SAAS,KAAK,YAAY,IAAI7E,IAAI,CAAC6E,SAAS,KAAK,KAAK,EAAE;YAC/D,OAAO,IAAI;UACb;QACF;MACF,CAAC;MAED,IAAA3G,kCAAA,WAA2B,EAAe2F,UAAU,EAAElE,OAAO,EAAAyD,MAAA,CAAAC,MAAA;QAC3D9D,IAAI,EAAE,IAAI,CAACA,IAAI;QACfqB,KAAK,EAAE,IAAI,CAACiD,UAAU,CAACjD,KAAK;QAC5BwB,oBAAoB,EAAE,IAAI,CAACA,oBAAoB;QAC/C9C,QAAQ,EAAE,IAAI,CAACA,QAAQ;QACvBE,eAAe,EAAE,IAAI,CAACA,eAAe;QACrC0C,YAAY,EAAE,IAAI,CAACA,YAAY,CAAC4C,IAAI,CAAC,IAAI,CAAC;QAC1CxB,WAAW,EAAE,IAAI,CAACA,WAAW,CAACwB,IAAI,CAAC,IAAI,CAAC;QAExCC,QAAQ,EAAEJ,OAAO,CAAC9C;MAAG,GAClB8C,OAAO,CACX,CAAC;IACJ;EAAA;AAAA;AACD1F,OAAA,cAAAwE,aAAA","ignoreList":[]}