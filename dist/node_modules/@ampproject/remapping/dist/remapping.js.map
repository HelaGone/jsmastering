{"version":3,"file":"remapping.js","names":["SOURCELESS_MAPPING","SegmentObject","EMPTY_SOURCES","source","line","column","name","content","ignore","Source","map","sources","MapSource","OriginalSource","traceMappings","tree","gen","GenMapping","file","rootSources","rootNames","names","rootMappings","decodedMappings","i","length","segments","j","segment","genCol","traced","originalPositionFor","_traced","maybeAddSegment","setSourceContent","setIgnore","traceSegment","asArray","value","Array","isArray","buildSourceMapTree","input","loader","maps","m","TraceMap","pop","Error","concat","build","importer","importerDepth","resolvedSources","sourcesContent","ignoreList","depth","children","sourceFile","ctx","undefined","sourceMap","sourceContent","ignored","includes","SourceMap","options","_classCallCheck","out","toDecodedMap","toEncodedMap","version","mappings","sourceRoot","excludeContent","_createClass","key","toString","JSON","stringify","remapping","opts","_typeof"],"sources":["../src/source-map-tree.ts","../src/build-source-map-tree.ts","../src/source-map.ts","../src/remapping.ts"],"sourcesContent":["import { GenMapping, maybeAddSegment, setIgnore, setSourceContent } from '@jridgewell/gen-mapping';\nimport { traceSegment, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport type { TraceMap } from '@jridgewell/trace-mapping';\n\nexport type SourceMapSegmentObject = {\n  column: number;\n  line: number;\n  name: string;\n  source: string;\n  content: string | null;\n  ignore: boolean;\n};\n\nexport type OriginalSource = {\n  map: null;\n  sources: Sources[];\n  source: string;\n  content: string | null;\n  ignore: boolean;\n};\n\nexport type MapSource = {\n  map: TraceMap;\n  sources: Sources[];\n  source: string;\n  content: null;\n  ignore: false;\n};\n\nexport type Sources = OriginalSource | MapSource;\n\nconst SOURCELESS_MAPPING = /* #__PURE__ */ SegmentObject('', -1, -1, '', null, false);\nconst EMPTY_SOURCES: Sources[] = [];\n\nfunction SegmentObject(\n  source: string,\n  line: number,\n  column: number,\n  name: string,\n  content: string | null,\n  ignore: boolean\n): SourceMapSegmentObject {\n  return { source, line, column, name, content, ignore };\n}\n\nfunction Source(\n  map: TraceMap,\n  sources: Sources[],\n  source: '',\n  content: null,\n  ignore: false\n): MapSource;\nfunction Source(\n  map: null,\n  sources: Sources[],\n  source: string,\n  content: string | null,\n  ignore: boolean\n): OriginalSource;\nfunction Source(\n  map: TraceMap | null,\n  sources: Sources[],\n  source: string | '',\n  content: string | null,\n  ignore: boolean\n): Sources {\n  return {\n    map,\n    sources,\n    source,\n    content,\n    ignore,\n  } as any;\n}\n\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\nexport function MapSource(map: TraceMap, sources: Sources[]): MapSource {\n  return Source(map, sources, '', null, false);\n}\n\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\nexport function OriginalSource(\n  source: string,\n  content: string | null,\n  ignore: boolean\n): OriginalSource {\n  return Source(null, EMPTY_SOURCES, source, content, ignore);\n}\n\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\nexport function traceMappings(tree: MapSource): GenMapping {\n  // TODO: Eventually support sourceRoot, which has to be removed because the sources are already\n  // fully resolved. We'll need to make sources relative to the sourceRoot before adding them.\n  const gen = new GenMapping({ file: tree.map.file });\n  const { sources: rootSources, map } = tree;\n  const rootNames = map.names;\n  const rootMappings = decodedMappings(map);\n\n  for (let i = 0; i < rootMappings.length; i++) {\n    const segments = rootMappings[i];\n\n    for (let j = 0; j < segments.length; j++) {\n      const segment = segments[j];\n      const genCol = segment[0];\n      let traced: SourceMapSegmentObject | null = SOURCELESS_MAPPING;\n\n      // 1-length segments only move the current generated column, there's no source information\n      // to gather from it.\n      if (segment.length !== 1) {\n        const source = rootSources[segment[1]];\n        traced = originalPositionFor(\n          source,\n          segment[2],\n          segment[3],\n          segment.length === 5 ? rootNames[segment[4]] : ''\n        );\n\n        // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n        // respective segment into an original source.\n        if (traced == null) continue;\n      }\n\n      const { column, line, name, content, source, ignore } = traced;\n\n      maybeAddSegment(gen, i, genCol, source, line, column, name);\n      if (source && content != null) setSourceContent(gen, source, content);\n      if (ignore) setIgnore(gen, source, true);\n    }\n  }\n\n  return gen;\n}\n\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\nexport function originalPositionFor(\n  source: Sources,\n  line: number,\n  column: number,\n  name: string\n): SourceMapSegmentObject | null {\n  if (!source.map) {\n    return SegmentObject(source.source, line, column, name, source.content, source.ignore);\n  }\n\n  const segment = traceSegment(source.map, line, column);\n\n  // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n  if (segment == null) return null;\n  // 1-length segments only move the current generated column, there's no source information\n  // to gather from it.\n  if (segment.length === 1) return SOURCELESS_MAPPING;\n\n  return originalPositionFor(\n    source.sources[segment[1]],\n    segment[2],\n    segment[3],\n    segment.length === 5 ? source.map.names[segment[4]] : name\n  );\n}\n","import { TraceMap } from '@jridgewell/trace-mapping';\n\nimport { OriginalSource, MapSource } from './source-map-tree';\n\nimport type { Sources, MapSource as MapSourceType } from './source-map-tree';\nimport type { SourceMapInput, SourceMapLoader, LoaderContext } from './types';\n\nfunction asArray<T>(value: T | T[]): T[] {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\n\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\nexport default function buildSourceMapTree(\n  input: SourceMapInput | SourceMapInput[],\n  loader: SourceMapLoader\n): MapSourceType {\n  const maps = asArray(input).map((m) => new TraceMap(m, ''));\n  const map = maps.pop()!;\n\n  for (let i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(\n        `Transformation map ${i} must have exactly one source file.\\n` +\n          'Did you specify these with the most recent transformation maps first?'\n      );\n    }\n  }\n\n  let tree = build(map, loader, '', 0);\n  for (let i = maps.length - 1; i >= 0; i--) {\n    tree = MapSource(maps[i], [tree]);\n  }\n  return tree;\n}\n\nfunction build(\n  map: TraceMap,\n  loader: SourceMapLoader,\n  importer: string,\n  importerDepth: number\n): MapSourceType {\n  const { resolvedSources, sourcesContent, ignoreList } = map;\n\n  const depth = importerDepth + 1;\n  const children = resolvedSources.map((sourceFile: string | null, i: number): Sources => {\n    // The loading context gives the loader more information about why this file is being loaded\n    // (eg, from which importer). It also allows the loader to override the location of the loaded\n    // sourcemap/original source, or to override the content in the sourcesContent field if it's\n    // an unmodified source file.\n    const ctx: LoaderContext = {\n      importer,\n      depth,\n      source: sourceFile || '',\n      content: undefined,\n      ignore: undefined,\n    };\n\n    // Use the provided loader callback to retrieve the file's sourcemap.\n    // TODO: We should eventually support async loading of sourcemap files.\n    const sourceMap = loader(ctx.source, ctx);\n\n    const { source, content, ignore } = ctx;\n\n    // If there is a sourcemap, then we need to recurse into it to load its source files.\n    if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth);\n\n    // Else, it's an unmodified source file.\n    // The contents of this unmodified source file can be overridden via the loader context,\n    // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n    // the importing sourcemap's `sourcesContent` field.\n    const sourceContent =\n      content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n    const ignored = ignore !== undefined ? ignore : ignoreList ? ignoreList.includes(i) : false;\n    return OriginalSource(source, sourceContent, ignored);\n  });\n\n  return MapSource(map, children);\n}\n","import { toDecodedMap, toEncodedMap } from '@jridgewell/gen-mapping';\n\nimport type { GenMapping } from '@jridgewell/gen-mapping';\nimport type { DecodedSourceMap, EncodedSourceMap, Options } from './types';\n\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\nexport default class SourceMap {\n  declare file?: string | null;\n  declare mappings: EncodedSourceMap['mappings'] | DecodedSourceMap['mappings'];\n  declare sourceRoot?: string;\n  declare names: string[];\n  declare sources: (string | null)[];\n  declare sourcesContent?: (string | null)[];\n  declare version: 3;\n  declare ignoreList: number[] | undefined;\n\n  constructor(map: GenMapping, options: Options) {\n    const out = options.decodedMappings ? toDecodedMap(map) : toEncodedMap(map);\n    this.version = out.version; // SourceMap spec says this should be first.\n    this.file = out.file;\n    this.mappings = out.mappings as SourceMap['mappings'];\n    this.names = out.names as SourceMap['names'];\n    this.ignoreList = out.ignoreList as SourceMap['ignoreList'];\n    this.sourceRoot = out.sourceRoot;\n\n    this.sources = out.sources as SourceMap['sources'];\n    if (!options.excludeContent) {\n      this.sourcesContent = out.sourcesContent as SourceMap['sourcesContent'];\n    }\n  }\n\n  toString(): string {\n    return JSON.stringify(this);\n  }\n}\n","import buildSourceMapTree from './build-source-map-tree';\nimport { traceMappings } from './source-map-tree';\nimport SourceMap from './source-map';\n\nimport type { SourceMapInput, SourceMapLoader, Options } from './types';\nexport type {\n  SourceMapSegment,\n  EncodedSourceMap,\n  EncodedSourceMap as RawSourceMap,\n  DecodedSourceMap,\n  SourceMapInput,\n  SourceMapLoader,\n  LoaderContext,\n  Options,\n} from './types';\nexport type { SourceMap };\n\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\nexport default function remapping(\n  input: SourceMapInput | SourceMapInput[],\n  loader: SourceMapLoader,\n  options?: boolean | Options\n): SourceMap {\n  const opts =\n    typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };\n  const tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\n"],"mappings":"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","ignoreList":[]}